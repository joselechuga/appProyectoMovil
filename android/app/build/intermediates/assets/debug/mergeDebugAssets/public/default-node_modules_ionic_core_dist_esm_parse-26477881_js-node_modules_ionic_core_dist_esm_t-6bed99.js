"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["default-node_modules_ionic_core_dist_esm_parse-26477881_js-node_modules_ionic_core_dist_esm_t-6bed99"],{

/***/ 9273:
/*!*************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/index-c4b11676.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "a": () => (/* binding */ printRequiredElementError),
/* harmony export */   "b": () => (/* binding */ printIonError),
/* harmony export */   "p": () => (/* binding */ printIonWarning)
/* harmony export */ });
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */

/**
 * Logs a warning to the console with an Ionic prefix
 * to indicate the library that is warning the developer.
 *
 * @param message - The string message to be logged to the console.
 */
const printIonWarning = (message, ...params) => {
  return console.warn(`[Ionic Warning]: ${message}`, ...params);
};
/*
 * Logs an error to the console with an Ionic prefix
 * to indicate the library that is warning the developer.
 *
 * @param message - The string message to be logged to the console.
 * @param params - Additional arguments to supply to the console.error.
 */


const printIonError = (message, ...params) => {
  return console.error(`[Ionic Error]: ${message}`, ...params);
};
/**
 * Prints an error informing developers that an implementation requires an element to be used
 * within a specific selector.
 *
 * @param el The web component element this is requiring the element.
 * @param targetSelectors The selector or selectors that were not found.
 */


const printRequiredElementError = (el, ...targetSelectors) => {
  return console.error(`<${el.tagName.toLowerCase()}> must be used inside ${targetSelectors.join(' or ')}.`);
};



/***/ }),

/***/ 237:
/*!*************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/parse-26477881.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": () => (/* binding */ getMonthAndYear),
/* harmony export */   "B": () => (/* binding */ getDaysOfMonth),
/* harmony export */   "C": () => (/* binding */ generateMonths),
/* harmony export */   "D": () => (/* binding */ is24Hour),
/* harmony export */   "E": () => (/* binding */ getLocalizedTime),
/* harmony export */   "F": () => (/* binding */ getMonthAndDay),
/* harmony export */   "G": () => (/* binding */ formatValue),
/* harmony export */   "H": () => (/* binding */ getNextYear),
/* harmony export */   "I": () => (/* binding */ getPreviousYear),
/* harmony export */   "J": () => (/* binding */ clampDate),
/* harmony export */   "K": () => (/* binding */ parseAmPm),
/* harmony export */   "L": () => (/* binding */ calculateHourFromAMPM),
/* harmony export */   "M": () => (/* binding */ getLocalizedDateTime),
/* harmony export */   "N": () => (/* binding */ getMonthDayAndYear),
/* harmony export */   "a": () => (/* binding */ isAfter),
/* harmony export */   "b": () => (/* binding */ isSameDay),
/* harmony export */   "c": () => (/* binding */ getPreviousMonth),
/* harmony export */   "d": () => (/* binding */ getNextMonth),
/* harmony export */   "e": () => (/* binding */ getToday),
/* harmony export */   "f": () => (/* binding */ getPartsFromCalendarDay),
/* harmony export */   "g": () => (/* binding */ generateDayAriaLabel),
/* harmony export */   "h": () => (/* binding */ getEndOfWeek),
/* harmony export */   "i": () => (/* binding */ isBefore),
/* harmony export */   "j": () => (/* binding */ getStartOfWeek),
/* harmony export */   "k": () => (/* binding */ getPreviousDay),
/* harmony export */   "l": () => (/* binding */ getNextDay),
/* harmony export */   "m": () => (/* binding */ getPreviousWeek),
/* harmony export */   "n": () => (/* binding */ getNextWeek),
/* harmony export */   "o": () => (/* binding */ convertToArrayOfNumbers),
/* harmony export */   "p": () => (/* binding */ parseDate),
/* harmony export */   "q": () => (/* binding */ convertDataToISO),
/* harmony export */   "r": () => (/* binding */ getCombinedDateColumnData),
/* harmony export */   "s": () => (/* binding */ getMonthColumnData),
/* harmony export */   "t": () => (/* binding */ getDayColumnData),
/* harmony export */   "u": () => (/* binding */ getYearColumnData),
/* harmony export */   "v": () => (/* binding */ isMonthFirstLocale),
/* harmony export */   "w": () => (/* binding */ warnIfValueOutOfBounds),
/* harmony export */   "x": () => (/* binding */ getTimeColumnsData),
/* harmony export */   "y": () => (/* binding */ isLocaleDayPeriodRTL),
/* harmony export */   "z": () => (/* binding */ getDaysOfWeek)
/* harmony export */ });
/* harmony import */ var _index_c4b11676_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-c4b11676.js */ 9273);
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */

/**
 * Returns true if the selected day is equal to the reference day
 */

const isSameDay = (baseParts, compareParts) => {
  return baseParts.month === compareParts.month && baseParts.day === compareParts.day && baseParts.year === compareParts.year;
};
/**
 * Returns true is the selected day is before the reference day.
 */


const isBefore = (baseParts, compareParts) => {
  return baseParts.year < compareParts.year || baseParts.year === compareParts.year && baseParts.month < compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day && baseParts.day < compareParts.day;
};
/**
 * Returns true is the selected day is after the reference day.
 */


const isAfter = (baseParts, compareParts) => {
  return baseParts.year > compareParts.year || baseParts.year === compareParts.year && baseParts.month > compareParts.month || baseParts.year === compareParts.year && baseParts.month === compareParts.month && baseParts.day && baseParts.day > compareParts.day;
};

const warnIfValueOutOfBounds = (value, min, max) => {
  const valueArray = Array.isArray(value) ? value : [value];

  for (const val of valueArray) {
    if (min && isBefore(val, min) || max && isAfter(val, max)) {
      (0,_index_c4b11676_js__WEBPACK_IMPORTED_MODULE_0__.p)('The value provided to ion-datetime is out of bounds.\n\n' + `Min: ${JSON.stringify(min)}\n` + `Max: ${JSON.stringify(max)}\n` + `Value: ${JSON.stringify(value)}`);
      break;
    }
  }
};
/**
 * Determines if given year is a
 * leap year. Returns `true` if year
 * is a leap year. Returns `false`
 * otherwise.
 */


const isLeapYear = year => {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};

const is24Hour = (locale, hourCycle) => {
  /**
   * If developer has explicitly enabled h23 time
   * then return early and do not look at the system default.
   */
  if (hourCycle !== undefined) {
    return hourCycle === 'h23';
  }
  /**
   * If hourCycle was not specified, check the locale
   * that is set on the user's device. We first check the
   * Intl.DateTimeFormat hourCycle option as developers can encode this
   * option into the locale string. Example: `en-US-u-hc-h23`
   */


  const formatted = new Intl.DateTimeFormat(locale, {
    hour: 'numeric'
  });
  const options = formatted.resolvedOptions();

  if (options.hourCycle !== undefined) {
    return options.hourCycle === 'h23';
  }
  /**
   * If hourCycle is not specified (either through lack
   * of browser support or locale information) then fall
   * back to this slower hourCycle check.
   */


  const date = new Date('5/18/2021 00:00');
  const parts = formatted.formatToParts(date);
  const hour = parts.find(p => p.type === 'hour');

  if (!hour) {
    throw new Error('Hour value not found from DateTimeFormat');
  }

  return hour.value === '00';
};
/**
 * Given a date object, returns the number
 * of days in that month.
 * Month value begin at 1, not 0.
 * i.e. January = month 1.
 */


const getNumDaysInMonth = (month, year) => {
  return month === 4 || month === 6 || month === 9 || month === 11 ? 30 : month === 2 ? isLeapYear(year) ? 29 : 28 : 31;
};
/**
 * Certain locales display month then year while
 * others display year then month.
 * We can use Intl.DateTimeFormat to determine
 * the ordering for each locale.
 * The formatOptions param can be used to customize
 * which pieces of a date to compare against the month
 * with. For example, some locales render dd/mm/yyyy
 * while others render mm/dd/yyyy. This function can be
 * used for variations of the same "month first" check.
 */


const isMonthFirstLocale = (locale, formatOptions = {
  month: 'numeric',
  year: 'numeric'
}) => {
  /**
   * By setting month and year we guarantee that only
   * month, year, and literal (slashes '/', for example)
   * values are included in the formatToParts results.
   *
   * The ordering of the parts will be determined by
   * the locale. So if the month is the first value,
   * then we know month should be shown first. If the
   * year is the first value, then we know year should be shown first.
   *
   * This ordering can be controlled by customizing the locale property.
   */
  const parts = new Intl.DateTimeFormat(locale, formatOptions).formatToParts(new Date());
  return parts[0].type === 'month';
};
/**
 * Determines if the given locale formats the day period (am/pm) to the
 * left or right of the hour.
 * @param locale The locale to check.
 * @returns `true` if the locale formats the day period to the left of the hour.
 */


const isLocaleDayPeriodRTL = locale => {
  const parts = new Intl.DateTimeFormat(locale, {
    hour: 'numeric'
  }).formatToParts(new Date());
  return parts[0].type === 'dayPeriod';
};

const twoDigit = val => {
  return ('0' + (val !== undefined ? Math.abs(val) : '0')).slice(-2);
};

const fourDigit = val => {
  return ('000' + (val !== undefined ? Math.abs(val) : '0')).slice(-4);
};

function convertDataToISO(data) {
  if (Array.isArray(data)) {
    return data.map(parts => convertDataToISO(parts));
  } // https://www.w3.org/TR/NOTE-datetime


  let rtn = '';

  if (data.year !== undefined) {
    // YYYY
    rtn = fourDigit(data.year);

    if (data.month !== undefined) {
      // YYYY-MM
      rtn += '-' + twoDigit(data.month);

      if (data.day !== undefined) {
        // YYYY-MM-DD
        rtn += '-' + twoDigit(data.day);

        if (data.hour !== undefined) {
          // YYYY-MM-DDTHH:mm:SS
          rtn += `T${twoDigit(data.hour)}:${twoDigit(data.minute)}:00`;

          if (data.tzOffset === undefined) {
            // YYYY-MM-DDTHH:mm:SSZ
            rtn += 'Z';
          } else {
            // YYYY-MM-DDTHH:mm:SS+/-HH:mm
            rtn += (data.tzOffset > 0 ? '+' : '-') + twoDigit(Math.floor(Math.abs(data.tzOffset / 60))) + ':' + twoDigit(data.tzOffset % 60);
          }
        }
      }
    }
  } else if (data.hour !== undefined) {
    // HH:mm
    rtn = twoDigit(data.hour) + ':' + twoDigit(data.minute);
  }

  return rtn;
}
/**
 * Converts an 12 hour value to 24 hours.
 */


const convert12HourTo24Hour = (hour, ampm) => {
  if (ampm === undefined) {
    return hour;
  }
  /**
   * If AM and 12am
   * then return 00:00.
   * Otherwise just return
   * the hour since it is
   * already in 24 hour format.
   */


  if (ampm === 'am') {
    if (hour === 12) {
      return 0;
    }

    return hour;
  }
  /**
   * If PM and 12pm
   * just return 12:00
   * since it is already
   * in 24 hour format.
   * Otherwise add 12 hours
   * to the time.
   */


  if (hour === 12) {
    return 12;
  }

  return hour + 12;
};

const getStartOfWeek = refParts => {
  const {
    dayOfWeek
  } = refParts;

  if (dayOfWeek === null || dayOfWeek === undefined) {
    throw new Error('No day of week provided');
  }

  return subtractDays(refParts, dayOfWeek);
};

const getEndOfWeek = refParts => {
  const {
    dayOfWeek
  } = refParts;

  if (dayOfWeek === null || dayOfWeek === undefined) {
    throw new Error('No day of week provided');
  }

  return addDays(refParts, 6 - dayOfWeek);
};

const getNextDay = refParts => {
  return addDays(refParts, 1);
};

const getPreviousDay = refParts => {
  return subtractDays(refParts, 1);
};

const getPreviousWeek = refParts => {
  return subtractDays(refParts, 7);
};

const getNextWeek = refParts => {
  return addDays(refParts, 7);
};
/**
 * Given datetime parts, subtract
 * numDays from the date.
 * Returns a new DatetimeParts object
 * Currently can only go backward at most 1 month.
 */


const subtractDays = (refParts, numDays) => {
  const {
    month,
    day,
    year
  } = refParts;

  if (day === null) {
    throw new Error('No day provided');
  }

  const workingParts = {
    month,
    day,
    year
  };
  workingParts.day = day - numDays;
  /**
   * If wrapping to previous month
   * update days and decrement month
   */

  if (workingParts.day < 1) {
    workingParts.month -= 1;
  }
  /**
   * If moving to previous year, reset
   * month to December and decrement year
   */


  if (workingParts.month < 1) {
    workingParts.month = 12;
    workingParts.year -= 1;
  }
  /**
   * Determine how many days are in the current
   * month
   */


  if (workingParts.day < 1) {
    const daysInMonth = getNumDaysInMonth(workingParts.month, workingParts.year);
    /**
     * Take num days in month and add the
     * number of underflow days. This number will
     * be negative.
     * Example: 1 week before Jan 2, 2021 is
     * December 26, 2021 so:
     * 2 - 7 = -5
     * 31 + (-5) = 26
     */

    workingParts.day = daysInMonth + workingParts.day;
  }

  return workingParts;
};
/**
 * Given datetime parts, add
 * numDays to the date.
 * Returns a new DatetimeParts object
 * Currently can only go forward at most 1 month.
 */


const addDays = (refParts, numDays) => {
  const {
    month,
    day,
    year
  } = refParts;

  if (day === null) {
    throw new Error('No day provided');
  }

  const workingParts = {
    month,
    day,
    year
  };
  const daysInMonth = getNumDaysInMonth(month, year);
  workingParts.day = day + numDays;
  /**
   * If wrapping to next month
   * update days and increment month
   */

  if (workingParts.day > daysInMonth) {
    workingParts.day -= daysInMonth;
    workingParts.month += 1;
  }
  /**
   * If moving to next year, reset
   * month to January and increment year
   */


  if (workingParts.month > 12) {
    workingParts.month = 1;
    workingParts.year += 1;
  }

  return workingParts;
};
/**
 * Given DatetimeParts, generate the previous month.
 */


const getPreviousMonth = refParts => {
  /**
   * If current month is January, wrap backwards
   *  to December of the previous year.
   */
  const month = refParts.month === 1 ? 12 : refParts.month - 1;
  const year = refParts.month === 1 ? refParts.year - 1 : refParts.year;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};
/**
 * Given DatetimeParts, generate the next month.
 */


const getNextMonth = refParts => {
  /**
   * If current month is December, wrap forwards
   *  to January of the next year.
   */
  const month = refParts.month === 12 ? 1 : refParts.month + 1;
  const year = refParts.month === 12 ? refParts.year + 1 : refParts.year;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};

const changeYear = (refParts, yearDelta) => {
  const month = refParts.month;
  const year = refParts.year + yearDelta;
  const numDaysInMonth = getNumDaysInMonth(month, year);
  const day = numDaysInMonth < refParts.day ? numDaysInMonth : refParts.day;
  return {
    month,
    year,
    day
  };
};
/**
 * Given DatetimeParts, generate the previous year.
 */


const getPreviousYear = refParts => {
  return changeYear(refParts, -1);
};
/**
 * Given DatetimeParts, generate the next year.
 */


const getNextYear = refParts => {
  return changeYear(refParts, 1);
};
/**
 * If PM, then internal value should
 * be converted to 24-hr time.
 * Does not apply when public
 * values are already 24-hr time.
 */


const getInternalHourValue = (hour, use24Hour, ampm) => {
  if (use24Hour) {
    return hour;
  }

  return convert12HourTo24Hour(hour, ampm);
};
/**
 * Unless otherwise stated, all month values are
 * 1 indexed instead of the typical 0 index in JS Date.
 * Example:
 *   January = Month 0 when using JS Date
 *   January = Month 1 when using this datetime util
 */

/**
 * Given the current datetime parts and a new AM/PM value
 * calculate what the hour should be in 24-hour time format.
 * Used when toggling the AM/PM segment since we store our hours
 * in 24-hour time format internally.
 */


const calculateHourFromAMPM = (currentParts, newAMPM) => {
  const {
    ampm: currentAMPM,
    hour
  } = currentParts;
  let newHour = hour;
  /**
   * If going from AM --> PM, need to update the
   *
   */

  if (currentAMPM === 'am' && newAMPM === 'pm') {
    newHour = convert12HourTo24Hour(newHour, 'pm');
    /**
     * If going from PM --> AM
     */
  } else if (currentAMPM === 'pm' && newAMPM === 'am') {
    newHour = Math.abs(newHour - 12);
  }

  return newHour;
};

const getFormattedDayPeriod = dayPeriod => {
  if (dayPeriod === undefined) {
    return '';
  }

  return dayPeriod.toUpperCase();
};

const getLocalizedTime = (locale, refParts, use24Hour) => {
  if (refParts.hour === undefined || refParts.minute === undefined) {
    return 'Invalid Time';
  }

  return new Intl.DateTimeFormat(locale, {
    hour: 'numeric',
    minute: 'numeric',
    timeZone: 'UTC',
    hour12: !use24Hour
  }).format(new Date(convertDataToISO(Object.assign(Object.assign({}, refParts), {
    // TODO: FW-1831 will remove the need to manually set the tzOffset to undefined
    tzOffset: undefined
  }))));
};
/**
 * Adds padding to a time value so
 * that it is always 2 digits.
 */


const addTimePadding = value => {
  const valueToString = value.toString();

  if (valueToString.length > 1) {
    return valueToString;
  }

  return `0${valueToString}`;
};
/**
 * Formats the hour value so that it
 * is always 2 digits. Only applies
 * if using 12 hour format.
 */


const getFormattedHour = (hour, use24Hour) => {
  if (!use24Hour) {
    return hour.toString();
  }

  return addTimePadding(hour);
};
/**
 * Generates an aria-label to be read by screen readers
 * given a local, a date, and whether or not that date is
 * today's date.
 */


const generateDayAriaLabel = (locale, today, refParts) => {
  if (refParts.day === null) {
    return null;
  }
  /**
   * MM/DD/YYYY will return midnight in the user's timezone.
   */


  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  const labelString = new Intl.DateTimeFormat(locale, {
    weekday: 'long',
    month: 'long',
    day: 'numeric',
    timeZone: 'UTC'
  }).format(date);
  /**
   * If date is today, prepend "Today" so screen readers indicate
   * that the date is today.
   */

  return today ? `Today, ${labelString}` : labelString;
};
/**
 * Gets the day of the week, month, and day
 * Used for the header in MD mode.
 */


const getMonthAndDay = (locale, refParts) => {
  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  return new Intl.DateTimeFormat(locale, {
    weekday: 'short',
    month: 'short',
    day: 'numeric',
    timeZone: 'UTC'
  }).format(date);
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the month name and full year.
 * Example: May 2021
 */


const getMonthAndYear = (locale, refParts) => {
  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year} GMT+0000`);
  return new Intl.DateTimeFormat(locale, {
    month: 'long',
    year: 'numeric',
    timeZone: 'UTC'
  }).format(date);
};
/**
 * Given a locale and a date object,
 * return a formatted string that includes
 * the short month, numeric day, and full year.
 * Example: Apr 22, 2021
 */


const getMonthDayAndYear = (locale, refParts) => {
  return getLocalizedDateTime(locale, refParts, {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
};
/**
 * Wrapper function for Intl.DateTimeFormat.
 * Allows developers to apply an allowed format to DatetimeParts.
 * This function also has built in safeguards for older browser bugs
 * with Intl.DateTimeFormat.
 */


const getLocalizedDateTime = (locale, refParts, options) => {
  const timeString = !!refParts.hour && !!refParts.minute ? ` ${refParts.hour}:${refParts.minute}` : '';
  const date = new Date(`${refParts.month}/${refParts.day}/${refParts.year}${timeString} GMT+0000`);
  return new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, options), {
    timeZone: 'UTC'
  })).format(date);
};
/**
 * Gets a localized version of "Today"
 * Falls back to "Today" in English for
 * browsers that do not support RelativeTimeFormat.
 */


const getTodayLabel = locale => {
  if ('RelativeTimeFormat' in Intl) {
    const label = new Intl.RelativeTimeFormat(locale, {
      numeric: 'auto'
    }).format(0, 'day');
    return label.charAt(0).toUpperCase() + label.slice(1);
  } else {
    return 'Today';
  }
};
/**
 * When calling toISOString(), the browser
 * will convert the date to UTC time by either adding
 * or subtracting the time zone offset.
 * To work around this, we need to either add
 * or subtract the time zone offset to the Date
 * object prior to calling toISOString().
 * This allows us to get an ISO string
 * that is in the user's time zone.
 *
 * Example:
 * Time zone offset is 240
 * Meaning: The browser needs to add 240 minutes
 * to the Date object to get UTC time.
 * What Ionic does: We subtract 240 minutes
 * from the Date object. The browser then adds
 * 240 minutes in toISOString(). The result
 * is a time that is in the user's time zone
 * and not UTC.
 *
 * Note: Some timezones include minute adjustments
 * such as 30 or 45 minutes. This is why we use setMinutes
 * instead of setHours.
 * Example: India Standard Time
 * Timezone offset: -330 = -5.5 hours.
 *
 * List of timezones with 30 and 45 minute timezones:
 * https://www.timeanddate.com/time/time-zones-interesting.html
 */


const removeDateTzOffset = date => {
  const tzOffset = date.getTimezoneOffset();
  date.setMinutes(date.getMinutes() - tzOffset);
  return date;
};

const DATE_AM = removeDateTzOffset(new Date('2022T01:00'));
const DATE_PM = removeDateTzOffset(new Date('2022T13:00'));
/**
 * Formats the locale's string representation of the day period (am/pm) for a given
 * ref parts day period.
 *
 * @param locale The locale to format the day period in.
 * @param value The date string, in ISO format.
 * @returns The localized day period (am/pm) representation of the given value.
 */

const getLocalizedDayPeriod = (locale, dayPeriod) => {
  const date = dayPeriod === 'am' ? DATE_AM : DATE_PM;
  const localizedDayPeriod = new Intl.DateTimeFormat(locale, {
    hour: 'numeric',
    timeZone: 'UTC'
  }).formatToParts(date).find(part => part.type === 'dayPeriod');

  if (localizedDayPeriod) {
    return localizedDayPeriod.value;
  }

  return getFormattedDayPeriod(dayPeriod);
};
/**
 * Formats the datetime's value to a string, for use in the native input.
 *
 * @param value The value to format, either an ISO string or an array thereof.
 */


const formatValue = value => {
  return Array.isArray(value) ? value.join(',') : value;
};
/**
 * Returns the current date as
 * an ISO string in the user's
 * time zone.
 */


const getToday = () => {
  /**
   * ion-datetime intentionally does not
   * parse time zones/do automatic time zone
   * conversion when accepting user input.
   * However when we get today's date string,
   * we want it formatted relative to the user's
   * time zone.
   *
   * When calling toISOString(), the browser
   * will convert the date to UTC time by either adding
   * or subtracting the time zone offset.
   * To work around this, we need to either add
   * or subtract the time zone offset to the Date
   * object prior to calling toISOString().
   * This allows us to get an ISO string
   * that is in the user's time zone.
   */
  return removeDateTzOffset(new Date()).toISOString();
};

const minutes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59];
const hour12 = [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
const hour23 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
/**
 * Given a locale and a mode,
 * return an array with formatted days
 * of the week. iOS should display days
 * such as "Mon" or "Tue".
 * MD should display days such as "M"
 * or "T".
 */

const getDaysOfWeek = (locale, mode, firstDayOfWeek = 0) => {
  /**
   * Nov 1st, 2020 starts on a Sunday.
   * ion-datetime assumes weeks start on Sunday,
   * but is configurable via `firstDayOfWeek`.
   */
  const weekdayFormat = mode === 'ios' ? 'short' : 'narrow';
  const intl = new Intl.DateTimeFormat(locale, {
    weekday: weekdayFormat
  });
  const startDate = new Date('11/01/2020');
  const daysOfWeek = [];
  /**
   * For each day of the week,
   * get the day name.
   */

  for (let i = firstDayOfWeek; i < firstDayOfWeek + 7; i++) {
    const currentDate = new Date(startDate);
    currentDate.setDate(currentDate.getDate() + i);
    daysOfWeek.push(intl.format(currentDate));
  }

  return daysOfWeek;
};
/**
 * Returns an array containing all of the
 * days in a month for a given year. Values are
 * aligned with a week calendar starting on
 * the firstDayOfWeek value (Sunday by default)
 * using null values.
 */


const getDaysOfMonth = (month, year, firstDayOfWeek) => {
  const numDays = getNumDaysInMonth(month, year);
  const firstOfMonth = new Date(`${month}/1/${year}`).getDay();
  /**
   * To get the first day of the month aligned on the correct
   * day of the week, we need to determine how many "filler" days
   * to generate. These filler days as empty/disabled buttons
   * that fill the space of the days of the week before the first
   * of the month.
   *
   * There are two cases here:
   *
   * 1. If firstOfMonth = 4, firstDayOfWeek = 0 then the offset
   * is (4 - (0 + 1)) = 3. Since the offset loop goes from 0 to 3 inclusive,
   * this will generate 4 filler days (0, 1, 2, 3), and then day of week 4 will have
   * the first day of the month.
   *
   * 2. If firstOfMonth = 2, firstDayOfWeek = 4 then the offset
   * is (6 - (4 - 2)) = 4. Since the offset loop goes from 0 to 4 inclusive,
   * this will generate 5 filler days (0, 1, 2, 3, 4), and then day of week 5 will have
   * the first day of the month.
   */

  const offset = firstOfMonth >= firstDayOfWeek ? firstOfMonth - (firstDayOfWeek + 1) : 6 - (firstDayOfWeek - firstOfMonth);
  let days = [];

  for (let i = 1; i <= numDays; i++) {
    days.push({
      day: i,
      dayOfWeek: (offset + i) % 7
    });
  }

  for (let i = 0; i <= offset; i++) {
    days = [{
      day: null,
      dayOfWeek: null
    }, ...days];
  }

  return days;
};
/**
 * Given a local, reference datetime parts and option
 * max/min bound datetime parts, calculate the acceptable
 * hour and minute values according to the bounds and locale.
 */


const generateTime = (refParts, hourCycle = 'h12', minParts, maxParts, hourValues, minuteValues) => {
  const use24Hour = hourCycle === 'h23';
  let processedHours = use24Hour ? hour23 : hour12;
  let processedMinutes = minutes;
  let isAMAllowed = true;
  let isPMAllowed = true;

  if (hourValues) {
    processedHours = processedHours.filter(hour => hourValues.includes(hour));
  }

  if (minuteValues) {
    processedMinutes = processedMinutes.filter(minute => minuteValues.includes(minute));
  }

  if (minParts) {
    /**
     * If ref day is the same as the
     * minimum allowed day, filter hour/minute
     * values according to min hour and minute.
     */
    if (isSameDay(refParts, minParts)) {
      /**
       * Users may not always set the hour/minute for
       * min value (i.e. 2021-06-02) so we should allow
       * all hours/minutes in that case.
       */
      if (minParts.hour !== undefined) {
        processedHours = processedHours.filter(hour => {
          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;
          return (use24Hour ? hour : convertedHour) >= minParts.hour;
        });
        isAMAllowed = minParts.hour < 13;
      }

      if (minParts.minute !== undefined) {
        /**
         * The minimum minute range should not be enforced when
         * the hour is greater than the min hour.
         *
         * For example with a minimum range of 09:30, users
         * should be able to select 10:00-10:29 and beyond.
         */
        let isPastMinHour = false;

        if (minParts.hour !== undefined && refParts.hour !== undefined) {
          if (refParts.hour > minParts.hour) {
            isPastMinHour = true;
          }
        }

        processedMinutes = processedMinutes.filter(minute => {
          if (isPastMinHour) {
            return true;
          }

          return minute >= minParts.minute;
        });
      }
      /**
       * If ref day is before minimum
       * day do not render any hours/minute values
       */

    } else if (isBefore(refParts, minParts)) {
      processedHours = [];
      processedMinutes = [];
      isAMAllowed = isPMAllowed = false;
    }
  }

  if (maxParts) {
    /**
     * If ref day is the same as the
     * maximum allowed day, filter hour/minute
     * values according to max hour and minute.
     */
    if (isSameDay(refParts, maxParts)) {
      /**
       * Users may not always set the hour/minute for
       * max value (i.e. 2021-06-02) so we should allow
       * all hours/minutes in that case.
       */
      if (maxParts.hour !== undefined) {
        processedHours = processedHours.filter(hour => {
          const convertedHour = refParts.ampm === 'pm' ? (hour + 12) % 24 : hour;
          return (use24Hour ? hour : convertedHour) <= maxParts.hour;
        });
        isPMAllowed = maxParts.hour >= 13;
      }

      if (maxParts.minute !== undefined && refParts.hour === maxParts.hour) {
        // The available minutes should only be filtered when the hour is the same as the max hour.
        // For example if the max hour is 10:30 and the current hour is 10:00,
        // users should be able to select 00-30 minutes.
        // If the current hour is 09:00, users should be able to select 00-60 minutes.
        processedMinutes = processedMinutes.filter(minute => minute <= maxParts.minute);
      }
      /**
       * If ref day is after minimum
       * day do not render any hours/minute values
       */

    } else if (isAfter(refParts, maxParts)) {
      processedHours = [];
      processedMinutes = [];
      isAMAllowed = isPMAllowed = false;
    }
  }

  return {
    hours: processedHours,
    minutes: processedMinutes,
    am: isAMAllowed,
    pm: isPMAllowed
  };
};
/**
 * Given DatetimeParts, generate the previous,
 * current, and and next months.
 */


const generateMonths = refParts => {
  return [getPreviousMonth(refParts), {
    month: refParts.month,
    year: refParts.year,
    day: refParts.day
  }, getNextMonth(refParts)];
};

const getMonthColumnData = (locale, refParts, minParts, maxParts, monthValues, formatOptions = {
  month: 'long'
}) => {
  const {
    year
  } = refParts;
  const months = [];

  if (monthValues !== undefined) {
    let processedMonths = monthValues;

    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.month) !== undefined) {
      processedMonths = processedMonths.filter(month => month <= maxParts.month);
    }

    if ((minParts === null || minParts === void 0 ? void 0 : minParts.month) !== undefined) {
      processedMonths = processedMonths.filter(month => month >= minParts.month);
    }

    processedMonths.forEach(processedMonth => {
      const date = new Date(`${processedMonth}/1/${year} GMT+0000`);
      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      months.push({
        text: monthString,
        value: processedMonth
      });
    });
  } else {
    const maxMonth = maxParts && maxParts.year === year ? maxParts.month : 12;
    const minMonth = minParts && minParts.year === year ? minParts.month : 1;

    for (let i = minMonth; i <= maxMonth; i++) {
      /**
       *
       * There is a bug on iOS 14 where
       * Intl.DateTimeFormat takes into account
       * the local timezone offset when formatting dates.
       *
       * Forcing the timezone to 'UTC' fixes the issue. However,
       * we should keep this workaround as it is safer. In the event
       * this breaks in another browser, we will not be impacted
       * because all dates will be interpreted in UTC.
       *
       * Example:
       * new Intl.DateTimeFormat('en-US', { month: 'long' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // "March"
       * new Intl.DateTimeFormat('en-US', { month: 'long', timeZone: 'UTC' }).format(new Date('Sat Apr 01 2006 00:00:00 GMT-0400 (EDT)')) // "April"
       *
       * In certain timezones, iOS 14 shows the wrong
       * date for .toUTCString(). To combat this, we
       * force all of the timezones to GMT+0000 (UTC).
       *
       * Example:
       * Time Zone: Central European Standard Time
       * new Date('1/1/1992').toUTCString() // "Tue, 31 Dec 1991 23:00:00 GMT"
       * new Date('1/1/1992 GMT+0000').toUTCString() // "Wed, 01 Jan 1992 00:00:00 GMT"
       */
      const date = new Date(`${i}/1/${year} GMT+0000`);
      const monthString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      months.push({
        text: monthString,
        value: i
      });
    }
  }

  return months;
};
/**
 * Returns information regarding
 * selectable dates (i.e 1st, 2nd, 3rd, etc)
 * within a reference month.
 * @param locale The locale to format the date with
 * @param refParts The reference month/year to generate dates for
 * @param minParts The minimum bound on the date that can be returned
 * @param maxParts The maximum bound on the date that can be returned
 * @param dayValues The allowed date values
 * @returns Date data to be used in ion-picker-column-internal
 */


const getDayColumnData = (locale, refParts, minParts, maxParts, dayValues, formatOptions = {
  day: 'numeric'
}) => {
  const {
    month,
    year
  } = refParts;
  const days = [];
  /**
   * If we have max/min bounds that in the same
   * month/year as the refParts, we should
   * use the define day as the max/min day.
   * Otherwise, fallback to the max/min days in a month.
   */

  const numDaysInMonth = getNumDaysInMonth(month, year);
  const maxDay = (maxParts === null || maxParts === void 0 ? void 0 : maxParts.day) && maxParts.year === year && maxParts.month === month ? maxParts.day : numDaysInMonth;
  const minDay = (minParts === null || minParts === void 0 ? void 0 : minParts.day) && minParts.year === year && minParts.month === month ? minParts.day : 1;

  if (dayValues !== undefined) {
    let processedDays = dayValues;
    processedDays = processedDays.filter(day => day >= minDay && day <= maxDay);
    processedDays.forEach(processedDay => {
      const date = new Date(`${month}/${processedDay}/${year} GMT+0000`);
      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      days.push({
        text: dayString,
        value: processedDay
      });
    });
  } else {
    for (let i = minDay; i <= maxDay; i++) {
      const date = new Date(`${month}/${i}/${year} GMT+0000`);
      const dayString = new Intl.DateTimeFormat(locale, Object.assign(Object.assign({}, formatOptions), {
        timeZone: 'UTC'
      })).format(date);
      days.push({
        text: dayString,
        value: i
      });
    }
  }

  return days;
};

const getYearColumnData = (refParts, minParts, maxParts, yearValues) => {
  let processedYears = [];

  if (yearValues !== undefined) {
    processedYears = yearValues;

    if ((maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) !== undefined) {
      processedYears = processedYears.filter(year => year <= maxParts.year);
    }

    if ((minParts === null || minParts === void 0 ? void 0 : minParts.year) !== undefined) {
      processedYears = processedYears.filter(year => year >= minParts.year);
    }
  } else {
    const {
      year
    } = refParts;
    const maxYear = (maxParts === null || maxParts === void 0 ? void 0 : maxParts.year) || year;
    const minYear = (minParts === null || minParts === void 0 ? void 0 : minParts.year) || year - 100;

    for (let i = maxYear; i >= minYear; i--) {
      processedYears.push(i);
    }
  }

  return processedYears.map(year => ({
    text: `${year}`,
    value: year
  }));
};
/**
 * Given a starting date and an upper bound,
 * this functions returns an array of all
 * month objects in that range.
 */


const getAllMonthsInRange = (currentParts, maxParts) => {
  if (currentParts.month === maxParts.month && currentParts.year === maxParts.year) {
    return [currentParts];
  }

  return [currentParts, ...getAllMonthsInRange(getNextMonth(currentParts), maxParts)];
};
/**
 * Creates and returns picker items
 * that represent the days in a month.
 * Example: "Thu, Jun 2"
 */


const getCombinedDateColumnData = (locale, refParts, todayParts, minParts, maxParts, dayValues, monthValues) => {
  let items = [];
  let parts = [];
  /**
   * Get all month objects from the min date
   * to the max date. Note: Do not use getMonthColumnData
   * as that function only generates dates within a
   * single year.
   */

  let months = getAllMonthsInRange(minParts, maxParts);
  /**
   * Filter out any disallowed month values.
   */

  if (monthValues) {
    months = months.filter(({
      month
    }) => monthValues.includes(month));
  }
  /**
   * Get all of the days in the month.
   * From there, generate an array where
   * each item has the month, date, and day
   * of work as the text.
   */


  months.forEach(monthObject => {
    const referenceMonth = {
      month: monthObject.month,
      day: null,
      year: refParts.year
    };
    const monthDays = getDayColumnData(locale, referenceMonth, minParts, maxParts, dayValues, {
      month: 'short',
      day: 'numeric',
      weekday: 'short'
    });
    const dateParts = [];
    const dateColumnItems = [];
    monthDays.forEach(dayObject => {
      const isToday = isSameDay(Object.assign(Object.assign({}, referenceMonth), {
        day: dayObject.value
      }), todayParts);
      /**
       * Today's date should read as "Today" (localized)
       * not the actual date string
       */

      dateColumnItems.push({
        text: isToday ? getTodayLabel(locale) : dayObject.text,
        value: `${refParts.year}-${monthObject.month}-${dayObject.value}`
      });
      /**
       * When selecting a date in the wheel picker
       * we need access to the raw datetime parts data.
       * The picker column only accepts values of
       * type string or number, so we need to return
       * two sets of data: A data set to be passed
       * to the picker column, and a data set to
       * be used to reference the raw data when
       * updating the picker column value.
       */

      dateParts.push({
        month: monthObject.month,
        year: refParts.year,
        day: dayObject.value
      });
    });
    parts = [...parts, ...dateParts];
    items = [...items, ...dateColumnItems];
  });
  return {
    parts,
    items
  };
};

const getTimeColumnsData = (locale, refParts, hourCycle, minParts, maxParts, allowedHourValues, allowedMinuteVaues) => {
  const use24Hour = is24Hour(locale, hourCycle);
  const {
    hours,
    minutes,
    am,
    pm
  } = generateTime(refParts, use24Hour ? 'h23' : 'h12', minParts, maxParts, allowedHourValues, allowedMinuteVaues);
  const hoursItems = hours.map(hour => {
    return {
      text: getFormattedHour(hour, use24Hour),
      value: getInternalHourValue(hour, use24Hour, refParts.ampm)
    };
  });
  const minutesItems = minutes.map(minute => {
    return {
      text: addTimePadding(minute),
      value: minute
    };
  });
  const dayPeriodItems = [];

  if (am && !use24Hour) {
    dayPeriodItems.push({
      text: getLocalizedDayPeriod(locale, 'am'),
      value: 'am'
    });
  }

  if (pm && !use24Hour) {
    dayPeriodItems.push({
      text: getLocalizedDayPeriod(locale, 'pm'),
      value: 'pm'
    });
  }

  return {
    minutesData: minutesItems,
    hoursData: hoursItems,
    dayPeriodData: dayPeriodItems
  };
};

const ISO_8601_REGEXP = // eslint-disable-next-line no-useless-escape
/^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/; // eslint-disable-next-line no-useless-escape

const TIME_REGEXP = /^((\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
/**
 * Use to convert a string of comma separated numbers or
 * an array of numbers, and clean up any user input
 */

const convertToArrayOfNumbers = input => {
  if (input === undefined) {
    return;
  }

  let processedInput = input;

  if (typeof input === 'string') {
    // convert the string to an array of strings
    // auto remove any whitespace and [] characters
    processedInput = input.replace(/\[|\]|\s/g, '').split(',');
  }

  let values;

  if (Array.isArray(processedInput)) {
    // ensure each value is an actual number in the returned array
    values = processedInput.map(num => parseInt(num, 10)).filter(isFinite);
  } else {
    values = [processedInput];
  }

  return values;
};
/**
 * Extracts date information
 * from a .calendar-day element
 * into DatetimeParts.
 */


const getPartsFromCalendarDay = el => {
  return {
    month: parseInt(el.getAttribute('data-month'), 10),
    day: parseInt(el.getAttribute('data-day'), 10),
    year: parseInt(el.getAttribute('data-year'), 10),
    dayOfWeek: parseInt(el.getAttribute('data-day-of-week'), 10)
  };
};

function parseDate(val) {
  if (Array.isArray(val)) {
    return val.map(valStr => parseDate(valStr));
  } // manually parse IS0 cuz Date.parse cannot be trusted
  // ISO 8601 format: 1994-12-15T13:47:20Z


  let parse = null;

  if (val != null && val !== '') {
    // try parsing for just time first, HH:MM
    parse = TIME_REGEXP.exec(val);

    if (parse) {
      // adjust the array so it fits nicely with the datetime parse
      parse.unshift(undefined, undefined);
      parse[2] = parse[3] = undefined;
    } else {
      // try parsing for full ISO datetime
      parse = ISO_8601_REGEXP.exec(val);
    }
  }

  if (parse === null) {
    // wasn't able to parse the ISO datetime
    return undefined;
  } // ensure all the parse values exist with at least 0


  for (let i = 1; i < 8; i++) {
    parse[i] = parse[i] !== undefined ? parseInt(parse[i], 10) : undefined;
  }

  let tzOffset = 0;

  if (parse[9] && parse[10]) {
    // hours
    tzOffset = parseInt(parse[10], 10) * 60;

    if (parse[11]) {
      // minutes
      tzOffset += parseInt(parse[11], 10);
    }

    if (parse[9] === '-') {
      // + or -
      tzOffset *= -1;
    }
  } // can also get second and millisecond from parse[6] and parse[7] if needed


  return {
    year: parse[1],
    month: parse[2],
    day: parse[3],
    hour: parse[4],
    minute: parse[5],
    tzOffset
  };
}

const clampDate = (dateParts, minParts, maxParts) => {
  if (minParts && isBefore(dateParts, minParts)) {
    return minParts;
  } else if (maxParts && isAfter(dateParts, maxParts)) {
    return maxParts;
  }

  return dateParts;
};
/**
 * Parses an hour and returns if the value is in the morning (am) or afternoon (pm).
 * @param hour The hour to format, should be 0-23
 * @returns `pm` if the hour is greater than or equal to 12, `am` if less than 12.
 */


const parseAmPm = hour => {
  return hour >= 12 ? 'pm' : 'am';
};



/***/ }),

/***/ 320:
/*!*************************************************************!*\
  !*** ./node_modules/@ionic/core/dist/esm/theme-7670341c.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": () => (/* binding */ createColorClasses),
/* harmony export */   "g": () => (/* binding */ getClassMap),
/* harmony export */   "h": () => (/* binding */ hostContext),
/* harmony export */   "o": () => (/* binding */ openURL)
/* harmony export */ });
/* harmony import */ var C_Users_evild_Documents_Repositorio_appProyectoMovil_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 1670);


/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
const hostContext = (selector, el) => {
  return el.closest(selector) !== null;
};
/**
 * Create the mode and color classes for the component based on the classes passed in
 */


const createColorClasses = (color, cssClassMap) => {
  return typeof color === 'string' && color.length > 0 ? Object.assign({
    'ion-color': true,
    [`ion-color-${color}`]: true
  }, cssClassMap) : cssClassMap;
};

const getClassList = classes => {
  if (classes !== undefined) {
    const array = Array.isArray(classes) ? classes : classes.split(' ');
    return array.filter(c => c != null).map(c => c.trim()).filter(c => c !== '');
  }

  return [];
};

const getClassMap = classes => {
  const map = {};
  getClassList(classes).forEach(c => map[c] = true);
  return map;
};

const SCHEME = /^[a-z][a-z0-9+\-.]*:/;

const openURL = /*#__PURE__*/function () {
  var _ref = (0,C_Users_evild_Documents_Repositorio_appProyectoMovil_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (url, ev, direction, animation) {
    if (url != null && url[0] !== '#' && !SCHEME.test(url)) {
      const router = document.querySelector('ion-router');

      if (router) {
        if (ev != null) {
          ev.preventDefault();
        }

        return router.push(url, direction, animation);
      }
    }

    return false;
  });

  return function openURL(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmYXVsdC1ub2RlX21vZHVsZXNfaW9uaWNfY29yZV9kaXN0X2VzbV9wYXJzZS0yNjQ3Nzg4MV9qcy1ub2RlX21vZHVsZXNfaW9uaWNfY29yZV9kaXN0X2VzbV90LTZiZWQ5OS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsZUFBZSxHQUFHLENBQUNDLE9BQUQsRUFBVSxHQUFHQyxNQUFiLEtBQXdCO0VBQzlDLE9BQU9DLE9BQU8sQ0FBQ0MsSUFBUixDQUFjLG9CQUFtQkgsT0FBUSxFQUF6QyxFQUE0QyxHQUFHQyxNQUEvQyxDQUFQO0FBQ0QsQ0FGRDtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNRyxhQUFhLEdBQUcsQ0FBQ0osT0FBRCxFQUFVLEdBQUdDLE1BQWIsS0FBd0I7RUFDNUMsT0FBT0MsT0FBTyxDQUFDRyxLQUFSLENBQWUsa0JBQWlCTCxPQUFRLEVBQXhDLEVBQTJDLEdBQUdDLE1BQTlDLENBQVA7QUFDRCxDQUZEO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQU1LLHlCQUF5QixHQUFHLENBQUNDLEVBQUQsRUFBSyxHQUFHQyxlQUFSLEtBQTRCO0VBQzVELE9BQU9OLE9BQU8sQ0FBQ0csS0FBUixDQUFlLElBQUdFLEVBQUUsQ0FBQ0UsT0FBSCxDQUFXQyxXQUFYLEVBQXlCLHlCQUF3QkYsZUFBZSxDQUFDRyxJQUFoQixDQUFxQixNQUFyQixDQUE2QixHQUFoRyxDQUFQO0FBQ0QsQ0FGRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBTUksU0FBUyxHQUFHLENBQUNDLFNBQUQsRUFBWUMsWUFBWixLQUE2QjtFQUM3QyxPQUFRRCxTQUFT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L2NvcmUvZGlzdC9lc20vaW5kZXgtYzRiMTE2NzYuanMiLCIuL25vZGVfbW9kdWxlcy9AaW9uaWMvY29yZS9kaXN0L2VzbS9wYXJzZS0yNjQ3Nzg4MS5qcyIsIi4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2Rpc3QvZXNtL3RoZW1lLTc2NzAzNDFjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG4vKipcbiAqIExvZ3MgYSB3YXJuaW5nIHRvIHRoZSBjb25zb2xlIHdpdGggYW4gSW9uaWMgcHJlZml4XG4gKiB0byBpbmRpY2F0ZSB0aGUgbGlicmFyeSB0aGF0IGlzIHdhcm5pbmcgdGhlIGRldmVsb3Blci5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBzdHJpbmcgbWVzc2FnZSB0byBiZSBsb2dnZWQgdG8gdGhlIGNvbnNvbGUuXG4gKi9cbmNvbnN0IHByaW50SW9uV2FybmluZyA9IChtZXNzYWdlLCAuLi5wYXJhbXMpID0+IHtcbiAgcmV0dXJuIGNvbnNvbGUud2FybihgW0lvbmljIFdhcm5pbmddOiAke21lc3NhZ2V9YCwgLi4ucGFyYW1zKTtcbn07XG4vKlxuICogTG9ncyBhbiBlcnJvciB0byB0aGUgY29uc29sZSB3aXRoIGFuIElvbmljIHByZWZpeFxuICogdG8gaW5kaWNhdGUgdGhlIGxpYnJhcnkgdGhhdCBpcyB3YXJuaW5nIHRoZSBkZXZlbG9wZXIuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgc3RyaW5nIG1lc3NhZ2UgdG8gYmUgbG9nZ2VkIHRvIHRoZSBjb25zb2xlLlxuICogQHBhcmFtIHBhcmFtcyAtIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHN1cHBseSB0byB0aGUgY29uc29sZS5lcnJvci5cbiAqL1xuY29uc3QgcHJpbnRJb25FcnJvciA9IChtZXNzYWdlLCAuLi5wYXJhbXMpID0+IHtcbiAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYFtJb25pYyBFcnJvcl06ICR7bWVzc2FnZX1gLCAuLi5wYXJhbXMpO1xufTtcbi8qKlxuICogUHJpbnRzIGFuIGVycm9yIGluZm9ybWluZyBkZXZlbG9wZXJzIHRoYXQgYW4gaW1wbGVtZW50YXRpb24gcmVxdWlyZXMgYW4gZWxlbWVudCB0byBiZSB1c2VkXG4gKiB3aXRoaW4gYSBzcGVjaWZpYyBzZWxlY3Rvci5cbiAqXG4gKiBAcGFyYW0gZWwgVGhlIHdlYiBjb21wb25lbnQgZWxlbWVudCB0aGlzIGlzIHJlcXVpcmluZyB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB0YXJnZXRTZWxlY3RvcnMgVGhlIHNlbGVjdG9yIG9yIHNlbGVjdG9ycyB0aGF0IHdlcmUgbm90IGZvdW5kLlxuICovXG5jb25zdCBwcmludFJlcXVpcmVkRWxlbWVudEVycm9yID0gKGVsLCAuLi50YXJnZXRTZWxlY3RvcnMpID0+IHtcbiAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYDwke2VsLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+IG11c3QgYmUgdXNlZCBpbnNpZGUgJHt0YXJnZXRTZWxlY3RvcnMuam9pbignIG9yICcpfS5gKTtcbn07XG5cbmV4cG9ydCB7IHByaW50UmVxdWlyZWRFbGVtZW50RXJyb3IgYXMgYSwgcHJpbnRJb25FcnJvciBhcyBiLCBwcmludElvbldhcm5pbmcgYXMgcCB9O1xuIiwiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHAgYXMgcHJpbnRJb25XYXJuaW5nIH0gZnJvbSAnLi9pbmRleC1jNGIxMTY3Ni5qcyc7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzZWxlY3RlZCBkYXkgaXMgZXF1YWwgdG8gdGhlIHJlZmVyZW5jZSBkYXlcbiAqL1xuY29uc3QgaXNTYW1lRGF5ID0gKGJhc2VQYXJ0cywgY29tcGFyZVBhcnRzKSA9PiB7XG4gIHJldHVybiAoYmFzZVBhcnRzLm1vbnRoID09PSBjb21wYXJlUGFydHMubW9udGggJiYgYmFzZVBhcnRzLmRheSA9PT0gY29tcGFyZVBhcnRzLmRheSAmJiBiYXNlUGFydHMueWVhciA9PT0gY29tcGFyZVBhcnRzLnllYXIpO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlzIHRoZSBzZWxlY3RlZCBkYXkgaXMgYmVmb3JlIHRoZSByZWZlcmVuY2UgZGF5LlxuICovXG5jb25zdCBpc0JlZm9yZSA9IChiYXNlUGFydHMsIGNvbXBhcmVQYXJ0cykgPT4ge1xuICByZXR1cm4gKGJhc2VQYXJ0cy55ZWFyIDwgY29tcGFyZVBhcnRzLnllYXIgfHxcbiAgICAoYmFzZVBhcnRzLnllYXIgPT09IGNvbXBhcmVQYXJ0cy55ZWFyICYmIGJhc2VQYXJ0cy5tb250aCA8IGNvbXBhcmVQYXJ0cy5tb250aCkgfHxcbiAgICAoYmFzZVBhcnRzLnllYXIgPT09IGNvbXBhcmVQYXJ0cy55ZWFyICYmXG4gICAgICBiYXNlUGFydHMubW9udGggPT09IGNvbXBhcmVQYXJ0cy5tb250aCAmJlxuICAgICAgYmFzZVBhcnRzLmRheSAmJlxuICAgICAgYmFzZVBhcnRzLmRheSA8IGNvbXBhcmVQYXJ0cy5kYXkpKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpcyB0aGUgc2VsZWN0ZWQgZGF5IGlzIGFmdGVyIHRoZSByZWZlcmVuY2UgZGF5LlxuICovXG5jb25zdCBpc0FmdGVyID0gKGJhc2VQYXJ0cywgY29tcGFyZVBhcnRzKSA9PiB7XG4gIHJldHVybiAoYmFzZVBhcnRzLnllYXIgPiBjb21wYXJlUGFydHMueWVhciB8fFxuICAgIChiYXNlUGFydHMueWVhciA9PT0gY29tcGFyZVBhcnRzLnllYXIgJiYgYmFzZVBhcnRzLm1vbnRoID4gY29tcGFyZVBhcnRzLm1vbnRoKSB8fFxuICAgIChiYXNlUGFydHMueWVhciA9PT0gY29tcGFyZVBhcnRzLnllYXIgJiZcbiAgICAgIGJhc2VQYXJ0cy5tb250aCA9PT0gY29tcGFyZVBhcnRzLm1vbnRoICYmXG4gICAgICBiYXNlUGFydHMuZGF5ICYmXG4gICAgICBiYXNlUGFydHMuZGF5ID4gY29tcGFyZVBhcnRzLmRheSkpO1xufTtcbmNvbnN0IHdhcm5JZlZhbHVlT3V0T2ZCb3VuZHMgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiB7XG4gIGNvbnN0IHZhbHVlQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgZm9yIChjb25zdCB2YWwgb2YgdmFsdWVBcnJheSkge1xuICAgIGlmICgobWluICYmIGlzQmVmb3JlKHZhbCwgbWluKSkgfHwgKG1heCAmJiBpc0FmdGVyKHZhbCwgbWF4KSkpIHtcbiAgICAgIHByaW50SW9uV2FybmluZygnVGhlIHZhbHVlIHByb3ZpZGVkIHRvIGlvbi1kYXRldGltZSBpcyBvdXQgb2YgYm91bmRzLlxcblxcbicgK1xuICAgICAgICBgTWluOiAke0pTT04uc3RyaW5naWZ5KG1pbil9XFxuYCArXG4gICAgICAgIGBNYXg6ICR7SlNPTi5zdHJpbmdpZnkobWF4KX1cXG5gICtcbiAgICAgICAgYFZhbHVlOiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGdpdmVuIHllYXIgaXMgYVxuICogbGVhcCB5ZWFyLiBSZXR1cm5zIGB0cnVlYCBpZiB5ZWFyXG4gKiBpcyBhIGxlYXAgeWVhci4gUmV0dXJucyBgZmFsc2VgXG4gKiBvdGhlcndpc2UuXG4gKi9cbmNvbnN0IGlzTGVhcFllYXIgPSAoeWVhcikgPT4ge1xuICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG59O1xuY29uc3QgaXMyNEhvdXIgPSAobG9jYWxlLCBob3VyQ3ljbGUpID0+IHtcbiAgLyoqXG4gICAqIElmIGRldmVsb3BlciBoYXMgZXhwbGljaXRseSBlbmFibGVkIGgyMyB0aW1lXG4gICAqIHRoZW4gcmV0dXJuIGVhcmx5IGFuZCBkbyBub3QgbG9vayBhdCB0aGUgc3lzdGVtIGRlZmF1bHQuXG4gICAqL1xuICBpZiAoaG91ckN5Y2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaG91ckN5Y2xlID09PSAnaDIzJztcbiAgfVxuICAvKipcbiAgICogSWYgaG91ckN5Y2xlIHdhcyBub3Qgc3BlY2lmaWVkLCBjaGVjayB0aGUgbG9jYWxlXG4gICAqIHRoYXQgaXMgc2V0IG9uIHRoZSB1c2VyJ3MgZGV2aWNlLiBXZSBmaXJzdCBjaGVjayB0aGVcbiAgICogSW50bC5EYXRlVGltZUZvcm1hdCBob3VyQ3ljbGUgb3B0aW9uIGFzIGRldmVsb3BlcnMgY2FuIGVuY29kZSB0aGlzXG4gICAqIG9wdGlvbiBpbnRvIHRoZSBsb2NhbGUgc3RyaW5nLiBFeGFtcGxlOiBgZW4tVVMtdS1oYy1oMjNgXG4gICAqL1xuICBjb25zdCBmb3JtYXR0ZWQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHsgaG91cjogJ251bWVyaWMnIH0pO1xuICBjb25zdCBvcHRpb25zID0gZm9ybWF0dGVkLnJlc29sdmVkT3B0aW9ucygpO1xuICBpZiAob3B0aW9ucy5ob3VyQ3ljbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBvcHRpb25zLmhvdXJDeWNsZSA9PT0gJ2gyMyc7XG4gIH1cbiAgLyoqXG4gICAqIElmIGhvdXJDeWNsZSBpcyBub3Qgc3BlY2lmaWVkIChlaXRoZXIgdGhyb3VnaCBsYWNrXG4gICAqIG9mIGJyb3dzZXIgc3VwcG9ydCBvciBsb2NhbGUgaW5mb3JtYXRpb24pIHRoZW4gZmFsbFxuICAgKiBiYWNrIHRvIHRoaXMgc2xvd2VyIGhvdXJDeWNsZSBjaGVjay5cbiAgICovXG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgnNS8xOC8yMDIxIDAwOjAwJyk7XG4gIGNvbnN0IHBhcnRzID0gZm9ybWF0dGVkLmZvcm1hdFRvUGFydHMoZGF0ZSk7XG4gIGNvbnN0IGhvdXIgPSBwYXJ0cy5maW5kKChwKSA9PiBwLnR5cGUgPT09ICdob3VyJyk7XG4gIGlmICghaG91cikge1xuICAgIHRocm93IG5ldyBFcnJvcignSG91ciB2YWx1ZSBub3QgZm91bmQgZnJvbSBEYXRlVGltZUZvcm1hdCcpO1xuICB9XG4gIHJldHVybiBob3VyLnZhbHVlID09PSAnMDAnO1xufTtcbi8qKlxuICogR2l2ZW4gYSBkYXRlIG9iamVjdCwgcmV0dXJucyB0aGUgbnVtYmVyXG4gKiBvZiBkYXlzIGluIHRoYXQgbW9udGguXG4gKiBNb250aCB2YWx1ZSBiZWdpbiBhdCAxLCBub3QgMC5cbiAqIGkuZS4gSmFudWFyeSA9IG1vbnRoIDEuXG4gKi9cbmNvbnN0IGdldE51bURheXNJbk1vbnRoID0gKG1vbnRoLCB5ZWFyKSA9PiB7XG4gIHJldHVybiBtb250aCA9PT0gNCB8fCBtb250aCA9PT0gNiB8fCBtb250aCA9PT0gOSB8fCBtb250aCA9PT0gMTFcbiAgICA/IDMwXG4gICAgOiBtb250aCA9PT0gMlxuICAgICAgPyBpc0xlYXBZZWFyKHllYXIpXG4gICAgICAgID8gMjlcbiAgICAgICAgOiAyOFxuICAgICAgOiAzMTtcbn07XG4vKipcbiAqIENlcnRhaW4gbG9jYWxlcyBkaXNwbGF5IG1vbnRoIHRoZW4geWVhciB3aGlsZVxuICogb3RoZXJzIGRpc3BsYXkgeWVhciB0aGVuIG1vbnRoLlxuICogV2UgY2FuIHVzZSBJbnRsLkRhdGVUaW1lRm9ybWF0IHRvIGRldGVybWluZVxuICogdGhlIG9yZGVyaW5nIGZvciBlYWNoIGxvY2FsZS5cbiAqIFRoZSBmb3JtYXRPcHRpb25zIHBhcmFtIGNhbiBiZSB1c2VkIHRvIGN1c3RvbWl6ZVxuICogd2hpY2ggcGllY2VzIG9mIGEgZGF0ZSB0byBjb21wYXJlIGFnYWluc3QgdGhlIG1vbnRoXG4gKiB3aXRoLiBGb3IgZXhhbXBsZSwgc29tZSBsb2NhbGVzIHJlbmRlciBkZC9tbS95eXl5XG4gKiB3aGlsZSBvdGhlcnMgcmVuZGVyIG1tL2RkL3l5eXkuIFRoaXMgZnVuY3Rpb24gY2FuIGJlXG4gKiB1c2VkIGZvciB2YXJpYXRpb25zIG9mIHRoZSBzYW1lIFwibW9udGggZmlyc3RcIiBjaGVjay5cbiAqL1xuY29uc3QgaXNNb250aEZpcnN0TG9jYWxlID0gKGxvY2FsZSwgZm9ybWF0T3B0aW9ucyA9IHtcbiAgbW9udGg6ICdudW1lcmljJyxcbiAgeWVhcjogJ251bWVyaWMnLFxufSkgPT4ge1xuICAvKipcbiAgICogQnkgc2V0dGluZyBtb250aCBhbmQgeWVhciB3ZSBndWFyYW50ZWUgdGhhdCBvbmx5XG4gICAqIG1vbnRoLCB5ZWFyLCBhbmQgbGl0ZXJhbCAoc2xhc2hlcyAnLycsIGZvciBleGFtcGxlKVxuICAgKiB2YWx1ZXMgYXJlIGluY2x1ZGVkIGluIHRoZSBmb3JtYXRUb1BhcnRzIHJlc3VsdHMuXG4gICAqXG4gICAqIFRoZSBvcmRlcmluZyBvZiB0aGUgcGFydHMgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5XG4gICAqIHRoZSBsb2NhbGUuIFNvIGlmIHRoZSBtb250aCBpcyB0aGUgZmlyc3QgdmFsdWUsXG4gICAqIHRoZW4gd2Uga25vdyBtb250aCBzaG91bGQgYmUgc2hvd24gZmlyc3QuIElmIHRoZVxuICAgKiB5ZWFyIGlzIHRoZSBmaXJzdCB2YWx1ZSwgdGhlbiB3ZSBrbm93IHllYXIgc2hvdWxkIGJlIHNob3duIGZpcnN0LlxuICAgKlxuICAgKiBUaGlzIG9yZGVyaW5nIGNhbiBiZSBjb250cm9sbGVkIGJ5IGN1c3RvbWl6aW5nIHRoZSBsb2NhbGUgcHJvcGVydHkuXG4gICAqL1xuICBjb25zdCBwYXJ0cyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgZm9ybWF0T3B0aW9ucykuZm9ybWF0VG9QYXJ0cyhuZXcgRGF0ZSgpKTtcbiAgcmV0dXJuIHBhcnRzWzBdLnR5cGUgPT09ICdtb250aCc7XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBsb2NhbGUgZm9ybWF0cyB0aGUgZGF5IHBlcmlvZCAoYW0vcG0pIHRvIHRoZVxuICogbGVmdCBvciByaWdodCBvZiB0aGUgaG91ci5cbiAqIEBwYXJhbSBsb2NhbGUgVGhlIGxvY2FsZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbG9jYWxlIGZvcm1hdHMgdGhlIGRheSBwZXJpb2QgdG8gdGhlIGxlZnQgb2YgdGhlIGhvdXIuXG4gKi9cbmNvbnN0IGlzTG9jYWxlRGF5UGVyaW9kUlRMID0gKGxvY2FsZSkgPT4ge1xuICBjb25zdCBwYXJ0cyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgeyBob3VyOiAnbnVtZXJpYycgfSkuZm9ybWF0VG9QYXJ0cyhuZXcgRGF0ZSgpKTtcbiAgcmV0dXJuIHBhcnRzWzBdLnR5cGUgPT09ICdkYXlQZXJpb2QnO1xufTtcblxuY29uc3QgdHdvRGlnaXQgPSAodmFsKSA9PiB7XG4gIHJldHVybiAoJzAnICsgKHZhbCAhPT0gdW5kZWZpbmVkID8gTWF0aC5hYnModmFsKSA6ICcwJykpLnNsaWNlKC0yKTtcbn07XG5jb25zdCBmb3VyRGlnaXQgPSAodmFsKSA9PiB7XG4gIHJldHVybiAoJzAwMCcgKyAodmFsICE9PSB1bmRlZmluZWQgPyBNYXRoLmFicyh2YWwpIDogJzAnKSkuc2xpY2UoLTQpO1xufTtcbmZ1bmN0aW9uIGNvbnZlcnREYXRhVG9JU08oZGF0YSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHJldHVybiBkYXRhLm1hcCgocGFydHMpID0+IGNvbnZlcnREYXRhVG9JU08ocGFydHMpKTtcbiAgfVxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvTk9URS1kYXRldGltZVxuICBsZXQgcnRuID0gJyc7XG4gIGlmIChkYXRhLnllYXIgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFlZWVlcbiAgICBydG4gPSBmb3VyRGlnaXQoZGF0YS55ZWFyKTtcbiAgICBpZiAoZGF0YS5tb250aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBZWVlZLU1NXG4gICAgICBydG4gKz0gJy0nICsgdHdvRGlnaXQoZGF0YS5tb250aCk7XG4gICAgICBpZiAoZGF0YS5kYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBZWVlZLU1NLUREXG4gICAgICAgIHJ0biArPSAnLScgKyB0d29EaWdpdChkYXRhLmRheSk7XG4gICAgICAgIGlmIChkYXRhLmhvdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFlZWVktTU0tRERUSEg6bW06U1NcbiAgICAgICAgICBydG4gKz0gYFQke3R3b0RpZ2l0KGRhdGEuaG91cil9OiR7dHdvRGlnaXQoZGF0YS5taW51dGUpfTowMGA7XG4gICAgICAgICAgaWYgKGRhdGEudHpPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gWVlZWS1NTS1ERFRISDptbTpTU1pcbiAgICAgICAgICAgIHJ0biArPSAnWic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gWVlZWS1NTS1ERFRISDptbTpTUysvLUhIOm1tXG4gICAgICAgICAgICBydG4gKz1cbiAgICAgICAgICAgICAgKGRhdGEudHpPZmZzZXQgPiAwID8gJysnIDogJy0nKSArXG4gICAgICAgICAgICAgICAgdHdvRGlnaXQoTWF0aC5mbG9vcihNYXRoLmFicyhkYXRhLnR6T2Zmc2V0IC8gNjApKSkgK1xuICAgICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgICAgdHdvRGlnaXQoZGF0YS50ek9mZnNldCAlIDYwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoZGF0YS5ob3VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBISDptbVxuICAgIHJ0biA9IHR3b0RpZ2l0KGRhdGEuaG91cikgKyAnOicgKyB0d29EaWdpdChkYXRhLm1pbnV0ZSk7XG4gIH1cbiAgcmV0dXJuIHJ0bjtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gMTIgaG91ciB2YWx1ZSB0byAyNCBob3Vycy5cbiAqL1xuY29uc3QgY29udmVydDEySG91clRvMjRIb3VyID0gKGhvdXIsIGFtcG0pID0+IHtcbiAgaWYgKGFtcG0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBob3VyO1xuICB9XG4gIC8qKlxuICAgKiBJZiBBTSBhbmQgMTJhbVxuICAgKiB0aGVuIHJldHVybiAwMDowMC5cbiAgICogT3RoZXJ3aXNlIGp1c3QgcmV0dXJuXG4gICAqIHRoZSBob3VyIHNpbmNlIGl0IGlzXG4gICAqIGFscmVhZHkgaW4gMjQgaG91ciBmb3JtYXQuXG4gICAqL1xuICBpZiAoYW1wbSA9PT0gJ2FtJykge1xuICAgIGlmIChob3VyID09PSAxMikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBob3VyO1xuICB9XG4gIC8qKlxuICAgKiBJZiBQTSBhbmQgMTJwbVxuICAgKiBqdXN0IHJldHVybiAxMjowMFxuICAgKiBzaW5jZSBpdCBpcyBhbHJlYWR5XG4gICAqIGluIDI0IGhvdXIgZm9ybWF0LlxuICAgKiBPdGhlcndpc2UgYWRkIDEyIGhvdXJzXG4gICAqIHRvIHRoZSB0aW1lLlxuICAgKi9cbiAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgcmV0dXJuIDEyO1xuICB9XG4gIHJldHVybiBob3VyICsgMTI7XG59O1xuY29uc3QgZ2V0U3RhcnRPZldlZWsgPSAocmVmUGFydHMpID0+IHtcbiAgY29uc3QgeyBkYXlPZldlZWsgfSA9IHJlZlBhcnRzO1xuICBpZiAoZGF5T2ZXZWVrID09PSBudWxsIHx8IGRheU9mV2VlayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXkgb2Ygd2VlayBwcm92aWRlZCcpO1xuICB9XG4gIHJldHVybiBzdWJ0cmFjdERheXMocmVmUGFydHMsIGRheU9mV2Vlayk7XG59O1xuY29uc3QgZ2V0RW5kT2ZXZWVrID0gKHJlZlBhcnRzKSA9PiB7XG4gIGNvbnN0IHsgZGF5T2ZXZWVrIH0gPSByZWZQYXJ0cztcbiAgaWYgKGRheU9mV2VlayA9PT0gbnVsbCB8fCBkYXlPZldlZWsgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF5IG9mIHdlZWsgcHJvdmlkZWQnKTtcbiAgfVxuICByZXR1cm4gYWRkRGF5cyhyZWZQYXJ0cywgNiAtIGRheU9mV2Vlayk7XG59O1xuY29uc3QgZ2V0TmV4dERheSA9IChyZWZQYXJ0cykgPT4ge1xuICByZXR1cm4gYWRkRGF5cyhyZWZQYXJ0cywgMSk7XG59O1xuY29uc3QgZ2V0UHJldmlvdXNEYXkgPSAocmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIHN1YnRyYWN0RGF5cyhyZWZQYXJ0cywgMSk7XG59O1xuY29uc3QgZ2V0UHJldmlvdXNXZWVrID0gKHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBzdWJ0cmFjdERheXMocmVmUGFydHMsIDcpO1xufTtcbmNvbnN0IGdldE5leHRXZWVrID0gKHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBhZGREYXlzKHJlZlBhcnRzLCA3KTtcbn07XG4vKipcbiAqIEdpdmVuIGRhdGV0aW1lIHBhcnRzLCBzdWJ0cmFjdFxuICogbnVtRGF5cyBmcm9tIHRoZSBkYXRlLlxuICogUmV0dXJucyBhIG5ldyBEYXRldGltZVBhcnRzIG9iamVjdFxuICogQ3VycmVudGx5IGNhbiBvbmx5IGdvIGJhY2t3YXJkIGF0IG1vc3QgMSBtb250aC5cbiAqL1xuY29uc3Qgc3VidHJhY3REYXlzID0gKHJlZlBhcnRzLCBudW1EYXlzKSA9PiB7XG4gIGNvbnN0IHsgbW9udGgsIGRheSwgeWVhciB9ID0gcmVmUGFydHM7XG4gIGlmIChkYXkgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRheSBwcm92aWRlZCcpO1xuICB9XG4gIGNvbnN0IHdvcmtpbmdQYXJ0cyA9IHtcbiAgICBtb250aCxcbiAgICBkYXksXG4gICAgeWVhcixcbiAgfTtcbiAgd29ya2luZ1BhcnRzLmRheSA9IGRheSAtIG51bURheXM7XG4gIC8qKlxuICAgKiBJZiB3cmFwcGluZyB0byBwcmV2aW91cyBtb250aFxuICAgKiB1cGRhdGUgZGF5cyBhbmQgZGVjcmVtZW50IG1vbnRoXG4gICAqL1xuICBpZiAod29ya2luZ1BhcnRzLmRheSA8IDEpIHtcbiAgICB3b3JraW5nUGFydHMubW9udGggLT0gMTtcbiAgfVxuICAvKipcbiAgICogSWYgbW92aW5nIHRvIHByZXZpb3VzIHllYXIsIHJlc2V0XG4gICAqIG1vbnRoIHRvIERlY2VtYmVyIGFuZCBkZWNyZW1lbnQgeWVhclxuICAgKi9cbiAgaWYgKHdvcmtpbmdQYXJ0cy5tb250aCA8IDEpIHtcbiAgICB3b3JraW5nUGFydHMubW9udGggPSAxMjtcbiAgICB3b3JraW5nUGFydHMueWVhciAtPSAxO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaG93IG1hbnkgZGF5cyBhcmUgaW4gdGhlIGN1cnJlbnRcbiAgICogbW9udGhcbiAgICovXG4gIGlmICh3b3JraW5nUGFydHMuZGF5IDwgMSkge1xuICAgIGNvbnN0IGRheXNJbk1vbnRoID0gZ2V0TnVtRGF5c0luTW9udGgod29ya2luZ1BhcnRzLm1vbnRoLCB3b3JraW5nUGFydHMueWVhcik7XG4gICAgLyoqXG4gICAgICogVGFrZSBudW0gZGF5cyBpbiBtb250aCBhbmQgYWRkIHRoZVxuICAgICAqIG51bWJlciBvZiB1bmRlcmZsb3cgZGF5cy4gVGhpcyBudW1iZXIgd2lsbFxuICAgICAqIGJlIG5lZ2F0aXZlLlxuICAgICAqIEV4YW1wbGU6IDEgd2VlayBiZWZvcmUgSmFuIDIsIDIwMjEgaXNcbiAgICAgKiBEZWNlbWJlciAyNiwgMjAyMSBzbzpcbiAgICAgKiAyIC0gNyA9IC01XG4gICAgICogMzEgKyAoLTUpID0gMjZcbiAgICAgKi9cbiAgICB3b3JraW5nUGFydHMuZGF5ID0gZGF5c0luTW9udGggKyB3b3JraW5nUGFydHMuZGF5O1xuICB9XG4gIHJldHVybiB3b3JraW5nUGFydHM7XG59O1xuLyoqXG4gKiBHaXZlbiBkYXRldGltZSBwYXJ0cywgYWRkXG4gKiBudW1EYXlzIHRvIHRoZSBkYXRlLlxuICogUmV0dXJucyBhIG5ldyBEYXRldGltZVBhcnRzIG9iamVjdFxuICogQ3VycmVudGx5IGNhbiBvbmx5IGdvIGZvcndhcmQgYXQgbW9zdCAxIG1vbnRoLlxuICovXG5jb25zdCBhZGREYXlzID0gKHJlZlBhcnRzLCBudW1EYXlzKSA9PiB7XG4gIGNvbnN0IHsgbW9udGgsIGRheSwgeWVhciB9ID0gcmVmUGFydHM7XG4gIGlmIChkYXkgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRheSBwcm92aWRlZCcpO1xuICB9XG4gIGNvbnN0IHdvcmtpbmdQYXJ0cyA9IHtcbiAgICBtb250aCxcbiAgICBkYXksXG4gICAgeWVhcixcbiAgfTtcbiAgY29uc3QgZGF5c0luTW9udGggPSBnZXROdW1EYXlzSW5Nb250aChtb250aCwgeWVhcik7XG4gIHdvcmtpbmdQYXJ0cy5kYXkgPSBkYXkgKyBudW1EYXlzO1xuICAvKipcbiAgICogSWYgd3JhcHBpbmcgdG8gbmV4dCBtb250aFxuICAgKiB1cGRhdGUgZGF5cyBhbmQgaW5jcmVtZW50IG1vbnRoXG4gICAqL1xuICBpZiAod29ya2luZ1BhcnRzLmRheSA+IGRheXNJbk1vbnRoKSB7XG4gICAgd29ya2luZ1BhcnRzLmRheSAtPSBkYXlzSW5Nb250aDtcbiAgICB3b3JraW5nUGFydHMubW9udGggKz0gMTtcbiAgfVxuICAvKipcbiAgICogSWYgbW92aW5nIHRvIG5leHQgeWVhciwgcmVzZXRcbiAgICogbW9udGggdG8gSmFudWFyeSBhbmQgaW5jcmVtZW50IHllYXJcbiAgICovXG4gIGlmICh3b3JraW5nUGFydHMubW9udGggPiAxMikge1xuICAgIHdvcmtpbmdQYXJ0cy5tb250aCA9IDE7XG4gICAgd29ya2luZ1BhcnRzLnllYXIgKz0gMTtcbiAgfVxuICByZXR1cm4gd29ya2luZ1BhcnRzO1xufTtcbi8qKlxuICogR2l2ZW4gRGF0ZXRpbWVQYXJ0cywgZ2VuZXJhdGUgdGhlIHByZXZpb3VzIG1vbnRoLlxuICovXG5jb25zdCBnZXRQcmV2aW91c01vbnRoID0gKHJlZlBhcnRzKSA9PiB7XG4gIC8qKlxuICAgKiBJZiBjdXJyZW50IG1vbnRoIGlzIEphbnVhcnksIHdyYXAgYmFja3dhcmRzXG4gICAqICB0byBEZWNlbWJlciBvZiB0aGUgcHJldmlvdXMgeWVhci5cbiAgICovXG4gIGNvbnN0IG1vbnRoID0gcmVmUGFydHMubW9udGggPT09IDEgPyAxMiA6IHJlZlBhcnRzLm1vbnRoIC0gMTtcbiAgY29uc3QgeWVhciA9IHJlZlBhcnRzLm1vbnRoID09PSAxID8gcmVmUGFydHMueWVhciAtIDEgOiByZWZQYXJ0cy55ZWFyO1xuICBjb25zdCBudW1EYXlzSW5Nb250aCA9IGdldE51bURheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcbiAgY29uc3QgZGF5ID0gbnVtRGF5c0luTW9udGggPCByZWZQYXJ0cy5kYXkgPyBudW1EYXlzSW5Nb250aCA6IHJlZlBhcnRzLmRheTtcbiAgcmV0dXJuIHsgbW9udGgsIHllYXIsIGRheSB9O1xufTtcbi8qKlxuICogR2l2ZW4gRGF0ZXRpbWVQYXJ0cywgZ2VuZXJhdGUgdGhlIG5leHQgbW9udGguXG4gKi9cbmNvbnN0IGdldE5leHRNb250aCA9IChyZWZQYXJ0cykgPT4ge1xuICAvKipcbiAgICogSWYgY3VycmVudCBtb250aCBpcyBEZWNlbWJlciwgd3JhcCBmb3J3YXJkc1xuICAgKiAgdG8gSmFudWFyeSBvZiB0aGUgbmV4dCB5ZWFyLlxuICAgKi9cbiAgY29uc3QgbW9udGggPSByZWZQYXJ0cy5tb250aCA9PT0gMTIgPyAxIDogcmVmUGFydHMubW9udGggKyAxO1xuICBjb25zdCB5ZWFyID0gcmVmUGFydHMubW9udGggPT09IDEyID8gcmVmUGFydHMueWVhciArIDEgOiByZWZQYXJ0cy55ZWFyO1xuICBjb25zdCBudW1EYXlzSW5Nb250aCA9IGdldE51bURheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcbiAgY29uc3QgZGF5ID0gbnVtRGF5c0luTW9udGggPCByZWZQYXJ0cy5kYXkgPyBudW1EYXlzSW5Nb250aCA6IHJlZlBhcnRzLmRheTtcbiAgcmV0dXJuIHsgbW9udGgsIHllYXIsIGRheSB9O1xufTtcbmNvbnN0IGNoYW5nZVllYXIgPSAocmVmUGFydHMsIHllYXJEZWx0YSkgPT4ge1xuICBjb25zdCBtb250aCA9IHJlZlBhcnRzLm1vbnRoO1xuICBjb25zdCB5ZWFyID0gcmVmUGFydHMueWVhciArIHllYXJEZWx0YTtcbiAgY29uc3QgbnVtRGF5c0luTW9udGggPSBnZXROdW1EYXlzSW5Nb250aChtb250aCwgeWVhcik7XG4gIGNvbnN0IGRheSA9IG51bURheXNJbk1vbnRoIDwgcmVmUGFydHMuZGF5ID8gbnVtRGF5c0luTW9udGggOiByZWZQYXJ0cy5kYXk7XG4gIHJldHVybiB7IG1vbnRoLCB5ZWFyLCBkYXkgfTtcbn07XG4vKipcbiAqIEdpdmVuIERhdGV0aW1lUGFydHMsIGdlbmVyYXRlIHRoZSBwcmV2aW91cyB5ZWFyLlxuICovXG5jb25zdCBnZXRQcmV2aW91c1llYXIgPSAocmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIGNoYW5nZVllYXIocmVmUGFydHMsIC0xKTtcbn07XG4vKipcbiAqIEdpdmVuIERhdGV0aW1lUGFydHMsIGdlbmVyYXRlIHRoZSBuZXh0IHllYXIuXG4gKi9cbmNvbnN0IGdldE5leHRZZWFyID0gKHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBjaGFuZ2VZZWFyKHJlZlBhcnRzLCAxKTtcbn07XG4vKipcbiAqIElmIFBNLCB0aGVuIGludGVybmFsIHZhbHVlIHNob3VsZFxuICogYmUgY29udmVydGVkIHRvIDI0LWhyIHRpbWUuXG4gKiBEb2VzIG5vdCBhcHBseSB3aGVuIHB1YmxpY1xuICogdmFsdWVzIGFyZSBhbHJlYWR5IDI0LWhyIHRpbWUuXG4gKi9cbmNvbnN0IGdldEludGVybmFsSG91clZhbHVlID0gKGhvdXIsIHVzZTI0SG91ciwgYW1wbSkgPT4ge1xuICBpZiAodXNlMjRIb3VyKSB7XG4gICAgcmV0dXJuIGhvdXI7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnQxMkhvdXJUbzI0SG91cihob3VyLCBhbXBtKTtcbn07XG4vKipcbiAqIFVubGVzcyBvdGhlcndpc2Ugc3RhdGVkLCBhbGwgbW9udGggdmFsdWVzIGFyZVxuICogMSBpbmRleGVkIGluc3RlYWQgb2YgdGhlIHR5cGljYWwgMCBpbmRleCBpbiBKUyBEYXRlLlxuICogRXhhbXBsZTpcbiAqICAgSmFudWFyeSA9IE1vbnRoIDAgd2hlbiB1c2luZyBKUyBEYXRlXG4gKiAgIEphbnVhcnkgPSBNb250aCAxIHdoZW4gdXNpbmcgdGhpcyBkYXRldGltZSB1dGlsXG4gKi9cbi8qKlxuICogR2l2ZW4gdGhlIGN1cnJlbnQgZGF0ZXRpbWUgcGFydHMgYW5kIGEgbmV3IEFNL1BNIHZhbHVlXG4gKiBjYWxjdWxhdGUgd2hhdCB0aGUgaG91ciBzaG91bGQgYmUgaW4gMjQtaG91ciB0aW1lIGZvcm1hdC5cbiAqIFVzZWQgd2hlbiB0b2dnbGluZyB0aGUgQU0vUE0gc2VnbWVudCBzaW5jZSB3ZSBzdG9yZSBvdXIgaG91cnNcbiAqIGluIDI0LWhvdXIgdGltZSBmb3JtYXQgaW50ZXJuYWxseS5cbiAqL1xuY29uc3QgY2FsY3VsYXRlSG91ckZyb21BTVBNID0gKGN1cnJlbnRQYXJ0cywgbmV3QU1QTSkgPT4ge1xuICBjb25zdCB7IGFtcG06IGN1cnJlbnRBTVBNLCBob3VyIH0gPSBjdXJyZW50UGFydHM7XG4gIGxldCBuZXdIb3VyID0gaG91cjtcbiAgLyoqXG4gICAqIElmIGdvaW5nIGZyb20gQU0gLS0+IFBNLCBuZWVkIHRvIHVwZGF0ZSB0aGVcbiAgICpcbiAgICovXG4gIGlmIChjdXJyZW50QU1QTSA9PT0gJ2FtJyAmJiBuZXdBTVBNID09PSAncG0nKSB7XG4gICAgbmV3SG91ciA9IGNvbnZlcnQxMkhvdXJUbzI0SG91cihuZXdIb3VyLCAncG0nKTtcbiAgICAvKipcbiAgICAgKiBJZiBnb2luZyBmcm9tIFBNIC0tPiBBTVxuICAgICAqL1xuICB9XG4gIGVsc2UgaWYgKGN1cnJlbnRBTVBNID09PSAncG0nICYmIG5ld0FNUE0gPT09ICdhbScpIHtcbiAgICBuZXdIb3VyID0gTWF0aC5hYnMobmV3SG91ciAtIDEyKTtcbiAgfVxuICByZXR1cm4gbmV3SG91cjtcbn07XG5cbmNvbnN0IGdldEZvcm1hdHRlZERheVBlcmlvZCA9IChkYXlQZXJpb2QpID0+IHtcbiAgaWYgKGRheVBlcmlvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBkYXlQZXJpb2QudG9VcHBlckNhc2UoKTtcbn07XG5jb25zdCBnZXRMb2NhbGl6ZWRUaW1lID0gKGxvY2FsZSwgcmVmUGFydHMsIHVzZTI0SG91cikgPT4ge1xuICBpZiAocmVmUGFydHMuaG91ciA9PT0gdW5kZWZpbmVkIHx8IHJlZlBhcnRzLm1pbnV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICdJbnZhbGlkIFRpbWUnO1xuICB9XG4gIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgbWludXRlOiAnbnVtZXJpYycsXG4gICAgdGltZVpvbmU6ICdVVEMnLFxuICAgIGhvdXIxMjogIXVzZTI0SG91cixcbiAgfSkuZm9ybWF0KG5ldyBEYXRlKGNvbnZlcnREYXRhVG9JU08oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWZQYXJ0cyksIHsgXG4gICAgLy8gVE9ETzogRlctMTgzMSB3aWxsIHJlbW92ZSB0aGUgbmVlZCB0byBtYW51YWxseSBzZXQgdGhlIHR6T2Zmc2V0IHRvIHVuZGVmaW5lZFxuICAgIHR6T2Zmc2V0OiB1bmRlZmluZWQgfSkpKSk7XG59O1xuLyoqXG4gKiBBZGRzIHBhZGRpbmcgdG8gYSB0aW1lIHZhbHVlIHNvXG4gKiB0aGF0IGl0IGlzIGFsd2F5cyAyIGRpZ2l0cy5cbiAqL1xuY29uc3QgYWRkVGltZVBhZGRpbmcgPSAodmFsdWUpID0+IHtcbiAgY29uc3QgdmFsdWVUb1N0cmluZyA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIGlmICh2YWx1ZVRvU3RyaW5nLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gdmFsdWVUb1N0cmluZztcbiAgfVxuICByZXR1cm4gYDAke3ZhbHVlVG9TdHJpbmd9YDtcbn07XG4vKipcbiAqIEZvcm1hdHMgdGhlIGhvdXIgdmFsdWUgc28gdGhhdCBpdFxuICogaXMgYWx3YXlzIDIgZGlnaXRzLiBPbmx5IGFwcGxpZXNcbiAqIGlmIHVzaW5nIDEyIGhvdXIgZm9ybWF0LlxuICovXG5jb25zdCBnZXRGb3JtYXR0ZWRIb3VyID0gKGhvdXIsIHVzZTI0SG91cikgPT4ge1xuICBpZiAoIXVzZTI0SG91cikge1xuICAgIHJldHVybiBob3VyLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIGFkZFRpbWVQYWRkaW5nKGhvdXIpO1xufTtcbi8qKlxuICogR2VuZXJhdGVzIGFuIGFyaWEtbGFiZWwgdG8gYmUgcmVhZCBieSBzY3JlZW4gcmVhZGVyc1xuICogZ2l2ZW4gYSBsb2NhbCwgYSBkYXRlLCBhbmQgd2hldGhlciBvciBub3QgdGhhdCBkYXRlIGlzXG4gKiB0b2RheSdzIGRhdGUuXG4gKi9cbmNvbnN0IGdlbmVyYXRlRGF5QXJpYUxhYmVsID0gKGxvY2FsZSwgdG9kYXksIHJlZlBhcnRzKSA9PiB7XG4gIGlmIChyZWZQYXJ0cy5kYXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogTU0vREQvWVlZWSB3aWxsIHJldHVybiBtaWRuaWdodCBpbiB0aGUgdXNlcidzIHRpbWV6b25lLlxuICAgKi9cbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke3JlZlBhcnRzLm1vbnRofS8ke3JlZlBhcnRzLmRheX0vJHtyZWZQYXJ0cy55ZWFyfSBHTVQrMDAwMGApO1xuICBjb25zdCBsYWJlbFN0cmluZyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwge1xuICAgIHdlZWtkYXk6ICdsb25nJyxcbiAgICBtb250aDogJ2xvbmcnLFxuICAgIGRheTogJ251bWVyaWMnLFxuICAgIHRpbWVab25lOiAnVVRDJyxcbiAgfSkuZm9ybWF0KGRhdGUpO1xuICAvKipcbiAgICogSWYgZGF0ZSBpcyB0b2RheSwgcHJlcGVuZCBcIlRvZGF5XCIgc28gc2NyZWVuIHJlYWRlcnMgaW5kaWNhdGVcbiAgICogdGhhdCB0aGUgZGF0ZSBpcyB0b2RheS5cbiAgICovXG4gIHJldHVybiB0b2RheSA/IGBUb2RheSwgJHtsYWJlbFN0cmluZ31gIDogbGFiZWxTdHJpbmc7XG59O1xuLyoqXG4gKiBHZXRzIHRoZSBkYXkgb2YgdGhlIHdlZWssIG1vbnRoLCBhbmQgZGF5XG4gKiBVc2VkIGZvciB0aGUgaGVhZGVyIGluIE1EIG1vZGUuXG4gKi9cbmNvbnN0IGdldE1vbnRoQW5kRGF5ID0gKGxvY2FsZSwgcmVmUGFydHMpID0+IHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke3JlZlBhcnRzLm1vbnRofS8ke3JlZlBhcnRzLmRheX0vJHtyZWZQYXJ0cy55ZWFyfSBHTVQrMDAwMGApO1xuICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICdudW1lcmljJywgdGltZVpvbmU6ICdVVEMnIH0pLmZvcm1hdChkYXRlKTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlIGFuZCBhIGRhdGUgb2JqZWN0LFxuICogcmV0dXJuIGEgZm9ybWF0dGVkIHN0cmluZyB0aGF0IGluY2x1ZGVzXG4gKiB0aGUgbW9udGggbmFtZSBhbmQgZnVsbCB5ZWFyLlxuICogRXhhbXBsZTogTWF5IDIwMjFcbiAqL1xuY29uc3QgZ2V0TW9udGhBbmRZZWFyID0gKGxvY2FsZSwgcmVmUGFydHMpID0+IHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke3JlZlBhcnRzLm1vbnRofS8ke3JlZlBhcnRzLmRheX0vJHtyZWZQYXJ0cy55ZWFyfSBHTVQrMDAwMGApO1xuICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7IG1vbnRoOiAnbG9uZycsIHllYXI6ICdudW1lcmljJywgdGltZVpvbmU6ICdVVEMnIH0pLmZvcm1hdChkYXRlKTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbG9jYWxlIGFuZCBhIGRhdGUgb2JqZWN0LFxuICogcmV0dXJuIGEgZm9ybWF0dGVkIHN0cmluZyB0aGF0IGluY2x1ZGVzXG4gKiB0aGUgc2hvcnQgbW9udGgsIG51bWVyaWMgZGF5LCBhbmQgZnVsbCB5ZWFyLlxuICogRXhhbXBsZTogQXByIDIyLCAyMDIxXG4gKi9cbmNvbnN0IGdldE1vbnRoRGF5QW5kWWVhciA9IChsb2NhbGUsIHJlZlBhcnRzKSA9PiB7XG4gIHJldHVybiBnZXRMb2NhbGl6ZWREYXRlVGltZShsb2NhbGUsIHJlZlBhcnRzLCB7IG1vbnRoOiAnc2hvcnQnLCBkYXk6ICdudW1lcmljJywgeWVhcjogJ251bWVyaWMnIH0pO1xufTtcbi8qKlxuICogV3JhcHBlciBmdW5jdGlvbiBmb3IgSW50bC5EYXRlVGltZUZvcm1hdC5cbiAqIEFsbG93cyBkZXZlbG9wZXJzIHRvIGFwcGx5IGFuIGFsbG93ZWQgZm9ybWF0IHRvIERhdGV0aW1lUGFydHMuXG4gKiBUaGlzIGZ1bmN0aW9uIGFsc28gaGFzIGJ1aWx0IGluIHNhZmVndWFyZHMgZm9yIG9sZGVyIGJyb3dzZXIgYnVnc1xuICogd2l0aCBJbnRsLkRhdGVUaW1lRm9ybWF0LlxuICovXG5jb25zdCBnZXRMb2NhbGl6ZWREYXRlVGltZSA9IChsb2NhbGUsIHJlZlBhcnRzLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHRpbWVTdHJpbmcgPSAhIXJlZlBhcnRzLmhvdXIgJiYgISFyZWZQYXJ0cy5taW51dGUgPyBgICR7cmVmUGFydHMuaG91cn06JHtyZWZQYXJ0cy5taW51dGV9YCA6ICcnO1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7cmVmUGFydHMubW9udGh9LyR7cmVmUGFydHMuZGF5fS8ke3JlZlBhcnRzLnllYXJ9JHt0aW1lU3RyaW5nfSBHTVQrMDAwMGApO1xuICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHRpbWVab25lOiAnVVRDJyB9KSkuZm9ybWF0KGRhdGUpO1xufTtcbi8qKlxuICogR2V0cyBhIGxvY2FsaXplZCB2ZXJzaW9uIG9mIFwiVG9kYXlcIlxuICogRmFsbHMgYmFjayB0byBcIlRvZGF5XCIgaW4gRW5nbGlzaCBmb3JcbiAqIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgUmVsYXRpdmVUaW1lRm9ybWF0LlxuICovXG5jb25zdCBnZXRUb2RheUxhYmVsID0gKGxvY2FsZSkgPT4ge1xuICBpZiAoJ1JlbGF0aXZlVGltZUZvcm1hdCcgaW4gSW50bCkge1xuICAgIGNvbnN0IGxhYmVsID0gbmV3IEludGwuUmVsYXRpdmVUaW1lRm9ybWF0KGxvY2FsZSwgeyBudW1lcmljOiAnYXV0bycgfSkuZm9ybWF0KDAsICdkYXknKTtcbiAgICByZXR1cm4gbGFiZWwuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBsYWJlbC5zbGljZSgxKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gJ1RvZGF5JztcbiAgfVxufTtcbi8qKlxuICogV2hlbiBjYWxsaW5nIHRvSVNPU3RyaW5nKCksIHRoZSBicm93c2VyXG4gKiB3aWxsIGNvbnZlcnQgdGhlIGRhdGUgdG8gVVRDIHRpbWUgYnkgZWl0aGVyIGFkZGluZ1xuICogb3Igc3VidHJhY3RpbmcgdGhlIHRpbWUgem9uZSBvZmZzZXQuXG4gKiBUbyB3b3JrIGFyb3VuZCB0aGlzLCB3ZSBuZWVkIHRvIGVpdGhlciBhZGRcbiAqIG9yIHN1YnRyYWN0IHRoZSB0aW1lIHpvbmUgb2Zmc2V0IHRvIHRoZSBEYXRlXG4gKiBvYmplY3QgcHJpb3IgdG8gY2FsbGluZyB0b0lTT1N0cmluZygpLlxuICogVGhpcyBhbGxvd3MgdXMgdG8gZ2V0IGFuIElTTyBzdHJpbmdcbiAqIHRoYXQgaXMgaW4gdGhlIHVzZXIncyB0aW1lIHpvbmUuXG4gKlxuICogRXhhbXBsZTpcbiAqIFRpbWUgem9uZSBvZmZzZXQgaXMgMjQwXG4gKiBNZWFuaW5nOiBUaGUgYnJvd3NlciBuZWVkcyB0byBhZGQgMjQwIG1pbnV0ZXNcbiAqIHRvIHRoZSBEYXRlIG9iamVjdCB0byBnZXQgVVRDIHRpbWUuXG4gKiBXaGF0IElvbmljIGRvZXM6IFdlIHN1YnRyYWN0IDI0MCBtaW51dGVzXG4gKiBmcm9tIHRoZSBEYXRlIG9iamVjdC4gVGhlIGJyb3dzZXIgdGhlbiBhZGRzXG4gKiAyNDAgbWludXRlcyBpbiB0b0lTT1N0cmluZygpLiBUaGUgcmVzdWx0XG4gKiBpcyBhIHRpbWUgdGhhdCBpcyBpbiB0aGUgdXNlcidzIHRpbWUgem9uZVxuICogYW5kIG5vdCBVVEMuXG4gKlxuICogTm90ZTogU29tZSB0aW1lem9uZXMgaW5jbHVkZSBtaW51dGUgYWRqdXN0bWVudHNcbiAqIHN1Y2ggYXMgMzAgb3IgNDUgbWludXRlcy4gVGhpcyBpcyB3aHkgd2UgdXNlIHNldE1pbnV0ZXNcbiAqIGluc3RlYWQgb2Ygc2V0SG91cnMuXG4gKiBFeGFtcGxlOiBJbmRpYSBTdGFuZGFyZCBUaW1lXG4gKiBUaW1lem9uZSBvZmZzZXQ6IC0zMzAgPSAtNS41IGhvdXJzLlxuICpcbiAqIExpc3Qgb2YgdGltZXpvbmVzIHdpdGggMzAgYW5kIDQ1IG1pbnV0ZSB0aW1lem9uZXM6XG4gKiBodHRwczovL3d3dy50aW1lYW5kZGF0ZS5jb20vdGltZS90aW1lLXpvbmVzLWludGVyZXN0aW5nLmh0bWxcbiAqL1xuY29uc3QgcmVtb3ZlRGF0ZVR6T2Zmc2V0ID0gKGRhdGUpID0+IHtcbiAgY29uc3QgdHpPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIGRhdGUuc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSAtIHR6T2Zmc2V0KTtcbiAgcmV0dXJuIGRhdGU7XG59O1xuY29uc3QgREFURV9BTSA9IHJlbW92ZURhdGVUek9mZnNldChuZXcgRGF0ZSgnMjAyMlQwMTowMCcpKTtcbmNvbnN0IERBVEVfUE0gPSByZW1vdmVEYXRlVHpPZmZzZXQobmV3IERhdGUoJzIwMjJUMTM6MDAnKSk7XG4vKipcbiAqIEZvcm1hdHMgdGhlIGxvY2FsZSdzIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF5IHBlcmlvZCAoYW0vcG0pIGZvciBhIGdpdmVuXG4gKiByZWYgcGFydHMgZGF5IHBlcmlvZC5cbiAqXG4gKiBAcGFyYW0gbG9jYWxlIFRoZSBsb2NhbGUgdG8gZm9ybWF0IHRoZSBkYXkgcGVyaW9kIGluLlxuICogQHBhcmFtIHZhbHVlIFRoZSBkYXRlIHN0cmluZywgaW4gSVNPIGZvcm1hdC5cbiAqIEByZXR1cm5zIFRoZSBsb2NhbGl6ZWQgZGF5IHBlcmlvZCAoYW0vcG0pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB2YWx1ZS5cbiAqL1xuY29uc3QgZ2V0TG9jYWxpemVkRGF5UGVyaW9kID0gKGxvY2FsZSwgZGF5UGVyaW9kKSA9PiB7XG4gIGNvbnN0IGRhdGUgPSBkYXlQZXJpb2QgPT09ICdhbScgPyBEQVRFX0FNIDogREFURV9QTTtcbiAgY29uc3QgbG9jYWxpemVkRGF5UGVyaW9kID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7XG4gICAgaG91cjogJ251bWVyaWMnLFxuICAgIHRpbWVab25lOiAnVVRDJyxcbiAgfSlcbiAgICAuZm9ybWF0VG9QYXJ0cyhkYXRlKVxuICAgIC5maW5kKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09ICdkYXlQZXJpb2QnKTtcbiAgaWYgKGxvY2FsaXplZERheVBlcmlvZCkge1xuICAgIHJldHVybiBsb2NhbGl6ZWREYXlQZXJpb2QudmFsdWU7XG4gIH1cbiAgcmV0dXJuIGdldEZvcm1hdHRlZERheVBlcmlvZChkYXlQZXJpb2QpO1xufTtcbi8qKlxuICogRm9ybWF0cyB0aGUgZGF0ZXRpbWUncyB2YWx1ZSB0byBhIHN0cmluZywgZm9yIHVzZSBpbiB0aGUgbmF0aXZlIGlucHV0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gZm9ybWF0LCBlaXRoZXIgYW4gSVNPIHN0cmluZyBvciBhbiBhcnJheSB0aGVyZW9mLlxuICovXG5jb25zdCBmb3JtYXRWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsJykgOiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBkYXRlIGFzXG4gKiBhbiBJU08gc3RyaW5nIGluIHRoZSB1c2VyJ3NcbiAqIHRpbWUgem9uZS5cbiAqL1xuY29uc3QgZ2V0VG9kYXkgPSAoKSA9PiB7XG4gIC8qKlxuICAgKiBpb24tZGF0ZXRpbWUgaW50ZW50aW9uYWxseSBkb2VzIG5vdFxuICAgKiBwYXJzZSB0aW1lIHpvbmVzL2RvIGF1dG9tYXRpYyB0aW1lIHpvbmVcbiAgICogY29udmVyc2lvbiB3aGVuIGFjY2VwdGluZyB1c2VyIGlucHV0LlxuICAgKiBIb3dldmVyIHdoZW4gd2UgZ2V0IHRvZGF5J3MgZGF0ZSBzdHJpbmcsXG4gICAqIHdlIHdhbnQgaXQgZm9ybWF0dGVkIHJlbGF0aXZlIHRvIHRoZSB1c2VyJ3NcbiAgICogdGltZSB6b25lLlxuICAgKlxuICAgKiBXaGVuIGNhbGxpbmcgdG9JU09TdHJpbmcoKSwgdGhlIGJyb3dzZXJcbiAgICogd2lsbCBjb252ZXJ0IHRoZSBkYXRlIHRvIFVUQyB0aW1lIGJ5IGVpdGhlciBhZGRpbmdcbiAgICogb3Igc3VidHJhY3RpbmcgdGhlIHRpbWUgem9uZSBvZmZzZXQuXG4gICAqIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHdlIG5lZWQgdG8gZWl0aGVyIGFkZFxuICAgKiBvciBzdWJ0cmFjdCB0aGUgdGltZSB6b25lIG9mZnNldCB0byB0aGUgRGF0ZVxuICAgKiBvYmplY3QgcHJpb3IgdG8gY2FsbGluZyB0b0lTT1N0cmluZygpLlxuICAgKiBUaGlzIGFsbG93cyB1cyB0byBnZXQgYW4gSVNPIHN0cmluZ1xuICAgKiB0aGF0IGlzIGluIHRoZSB1c2VyJ3MgdGltZSB6b25lLlxuICAgKi9cbiAgcmV0dXJuIHJlbW92ZURhdGVUek9mZnNldChuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpO1xufTtcbmNvbnN0IG1pbnV0ZXMgPSBbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLCAyMywgMjQsIDI1LCAyNiwgMjcsIDI4LCAyOSwgMzAsIDMxLFxuICAzMiwgMzMsIDM0LCAzNSwgMzYsIDM3LCAzOCwgMzksIDQwLCA0MSwgNDIsIDQzLCA0NCwgNDUsIDQ2LCA0NywgNDgsIDQ5LCA1MCwgNTEsIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDU4LCA1OSxcbl07XG5jb25zdCBob3VyMTIgPSBbMTIsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMV07XG5jb25zdCBob3VyMjMgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzXTtcbi8qKlxuICogR2l2ZW4gYSBsb2NhbGUgYW5kIGEgbW9kZSxcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGZvcm1hdHRlZCBkYXlzXG4gKiBvZiB0aGUgd2Vlay4gaU9TIHNob3VsZCBkaXNwbGF5IGRheXNcbiAqIHN1Y2ggYXMgXCJNb25cIiBvciBcIlR1ZVwiLlxuICogTUQgc2hvdWxkIGRpc3BsYXkgZGF5cyBzdWNoIGFzIFwiTVwiXG4gKiBvciBcIlRcIi5cbiAqL1xuY29uc3QgZ2V0RGF5c09mV2VlayA9IChsb2NhbGUsIG1vZGUsIGZpcnN0RGF5T2ZXZWVrID0gMCkgPT4ge1xuICAvKipcbiAgICogTm92IDFzdCwgMjAyMCBzdGFydHMgb24gYSBTdW5kYXkuXG4gICAqIGlvbi1kYXRldGltZSBhc3N1bWVzIHdlZWtzIHN0YXJ0IG9uIFN1bmRheSxcbiAgICogYnV0IGlzIGNvbmZpZ3VyYWJsZSB2aWEgYGZpcnN0RGF5T2ZXZWVrYC5cbiAgICovXG4gIGNvbnN0IHdlZWtkYXlGb3JtYXQgPSBtb2RlID09PSAnaW9zJyA/ICdzaG9ydCcgOiAnbmFycm93JztcbiAgY29uc3QgaW50bCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgeyB3ZWVrZGF5OiB3ZWVrZGF5Rm9ybWF0IH0pO1xuICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZSgnMTEvMDEvMjAyMCcpO1xuICBjb25zdCBkYXlzT2ZXZWVrID0gW107XG4gIC8qKlxuICAgKiBGb3IgZWFjaCBkYXkgb2YgdGhlIHdlZWssXG4gICAqIGdldCB0aGUgZGF5IG5hbWUuXG4gICAqL1xuICBmb3IgKGxldCBpID0gZmlyc3REYXlPZldlZWs7IGkgPCBmaXJzdERheU9mV2VlayArIDc7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoc3RhcnREYXRlKTtcbiAgICBjdXJyZW50RGF0ZS5zZXREYXRlKGN1cnJlbnREYXRlLmdldERhdGUoKSArIGkpO1xuICAgIGRheXNPZldlZWsucHVzaChpbnRsLmZvcm1hdChjdXJyZW50RGF0ZSkpO1xuICB9XG4gIHJldHVybiBkYXlzT2ZXZWVrO1xufTtcbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiB0aGVcbiAqIGRheXMgaW4gYSBtb250aCBmb3IgYSBnaXZlbiB5ZWFyLiBWYWx1ZXMgYXJlXG4gKiBhbGlnbmVkIHdpdGggYSB3ZWVrIGNhbGVuZGFyIHN0YXJ0aW5nIG9uXG4gKiB0aGUgZmlyc3REYXlPZldlZWsgdmFsdWUgKFN1bmRheSBieSBkZWZhdWx0KVxuICogdXNpbmcgbnVsbCB2YWx1ZXMuXG4gKi9cbmNvbnN0IGdldERheXNPZk1vbnRoID0gKG1vbnRoLCB5ZWFyLCBmaXJzdERheU9mV2VlaykgPT4ge1xuICBjb25zdCBudW1EYXlzID0gZ2V0TnVtRGF5c0luTW9udGgobW9udGgsIHllYXIpO1xuICBjb25zdCBmaXJzdE9mTW9udGggPSBuZXcgRGF0ZShgJHttb250aH0vMS8ke3llYXJ9YCkuZ2V0RGF5KCk7XG4gIC8qKlxuICAgKiBUbyBnZXQgdGhlIGZpcnN0IGRheSBvZiB0aGUgbW9udGggYWxpZ25lZCBvbiB0aGUgY29ycmVjdFxuICAgKiBkYXkgb2YgdGhlIHdlZWssIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIGhvdyBtYW55IFwiZmlsbGVyXCIgZGF5c1xuICAgKiB0byBnZW5lcmF0ZS4gVGhlc2UgZmlsbGVyIGRheXMgYXMgZW1wdHkvZGlzYWJsZWQgYnV0dG9uc1xuICAgKiB0aGF0IGZpbGwgdGhlIHNwYWNlIG9mIHRoZSBkYXlzIG9mIHRoZSB3ZWVrIGJlZm9yZSB0aGUgZmlyc3RcbiAgICogb2YgdGhlIG1vbnRoLlxuICAgKlxuICAgKiBUaGVyZSBhcmUgdHdvIGNhc2VzIGhlcmU6XG4gICAqXG4gICAqIDEuIElmIGZpcnN0T2ZNb250aCA9IDQsIGZpcnN0RGF5T2ZXZWVrID0gMCB0aGVuIHRoZSBvZmZzZXRcbiAgICogaXMgKDQgLSAoMCArIDEpKSA9IDMuIFNpbmNlIHRoZSBvZmZzZXQgbG9vcCBnb2VzIGZyb20gMCB0byAzIGluY2x1c2l2ZSxcbiAgICogdGhpcyB3aWxsIGdlbmVyYXRlIDQgZmlsbGVyIGRheXMgKDAsIDEsIDIsIDMpLCBhbmQgdGhlbiBkYXkgb2Ygd2VlayA0IHdpbGwgaGF2ZVxuICAgKiB0aGUgZmlyc3QgZGF5IG9mIHRoZSBtb250aC5cbiAgICpcbiAgICogMi4gSWYgZmlyc3RPZk1vbnRoID0gMiwgZmlyc3REYXlPZldlZWsgPSA0IHRoZW4gdGhlIG9mZnNldFxuICAgKiBpcyAoNiAtICg0IC0gMikpID0gNC4gU2luY2UgdGhlIG9mZnNldCBsb29wIGdvZXMgZnJvbSAwIHRvIDQgaW5jbHVzaXZlLFxuICAgKiB0aGlzIHdpbGwgZ2VuZXJhdGUgNSBmaWxsZXIgZGF5cyAoMCwgMSwgMiwgMywgNCksIGFuZCB0aGVuIGRheSBvZiB3ZWVrIDUgd2lsbCBoYXZlXG4gICAqIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoLlxuICAgKi9cbiAgY29uc3Qgb2Zmc2V0ID0gZmlyc3RPZk1vbnRoID49IGZpcnN0RGF5T2ZXZWVrID8gZmlyc3RPZk1vbnRoIC0gKGZpcnN0RGF5T2ZXZWVrICsgMSkgOiA2IC0gKGZpcnN0RGF5T2ZXZWVrIC0gZmlyc3RPZk1vbnRoKTtcbiAgbGV0IGRheXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbnVtRGF5czsgaSsrKSB7XG4gICAgZGF5cy5wdXNoKHsgZGF5OiBpLCBkYXlPZldlZWs6IChvZmZzZXQgKyBpKSAlIDcgfSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gb2Zmc2V0OyBpKyspIHtcbiAgICBkYXlzID0gW3sgZGF5OiBudWxsLCBkYXlPZldlZWs6IG51bGwgfSwgLi4uZGF5c107XG4gIH1cbiAgcmV0dXJuIGRheXM7XG59O1xuLyoqXG4gKiBHaXZlbiBhIGxvY2FsLCByZWZlcmVuY2UgZGF0ZXRpbWUgcGFydHMgYW5kIG9wdGlvblxuICogbWF4L21pbiBib3VuZCBkYXRldGltZSBwYXJ0cywgY2FsY3VsYXRlIHRoZSBhY2NlcHRhYmxlXG4gKiBob3VyIGFuZCBtaW51dGUgdmFsdWVzIGFjY29yZGluZyB0byB0aGUgYm91bmRzIGFuZCBsb2NhbGUuXG4gKi9cbmNvbnN0IGdlbmVyYXRlVGltZSA9IChyZWZQYXJ0cywgaG91ckN5Y2xlID0gJ2gxMicsIG1pblBhcnRzLCBtYXhQYXJ0cywgaG91clZhbHVlcywgbWludXRlVmFsdWVzKSA9PiB7XG4gIGNvbnN0IHVzZTI0SG91ciA9IGhvdXJDeWNsZSA9PT0gJ2gyMyc7XG4gIGxldCBwcm9jZXNzZWRIb3VycyA9IHVzZTI0SG91ciA/IGhvdXIyMyA6IGhvdXIxMjtcbiAgbGV0IHByb2Nlc3NlZE1pbnV0ZXMgPSBtaW51dGVzO1xuICBsZXQgaXNBTUFsbG93ZWQgPSB0cnVlO1xuICBsZXQgaXNQTUFsbG93ZWQgPSB0cnVlO1xuICBpZiAoaG91clZhbHVlcykge1xuICAgIHByb2Nlc3NlZEhvdXJzID0gcHJvY2Vzc2VkSG91cnMuZmlsdGVyKChob3VyKSA9PiBob3VyVmFsdWVzLmluY2x1ZGVzKGhvdXIpKTtcbiAgfVxuICBpZiAobWludXRlVmFsdWVzKSB7XG4gICAgcHJvY2Vzc2VkTWludXRlcyA9IHByb2Nlc3NlZE1pbnV0ZXMuZmlsdGVyKChtaW51dGUpID0+IG1pbnV0ZVZhbHVlcy5pbmNsdWRlcyhtaW51dGUpKTtcbiAgfVxuICBpZiAobWluUGFydHMpIHtcbiAgICAvKipcbiAgICAgKiBJZiByZWYgZGF5IGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgICAqIG1pbmltdW0gYWxsb3dlZCBkYXksIGZpbHRlciBob3VyL21pbnV0ZVxuICAgICAqIHZhbHVlcyBhY2NvcmRpbmcgdG8gbWluIGhvdXIgYW5kIG1pbnV0ZS5cbiAgICAgKi9cbiAgICBpZiAoaXNTYW1lRGF5KHJlZlBhcnRzLCBtaW5QYXJ0cykpIHtcbiAgICAgIC8qKlxuICAgICAgICogVXNlcnMgbWF5IG5vdCBhbHdheXMgc2V0IHRoZSBob3VyL21pbnV0ZSBmb3JcbiAgICAgICAqIG1pbiB2YWx1ZSAoaS5lLiAyMDIxLTA2LTAyKSBzbyB3ZSBzaG91bGQgYWxsb3dcbiAgICAgICAqIGFsbCBob3Vycy9taW51dGVzIGluIHRoYXQgY2FzZS5cbiAgICAgICAqL1xuICAgICAgaWYgKG1pblBhcnRzLmhvdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9jZXNzZWRIb3VycyA9IHByb2Nlc3NlZEhvdXJzLmZpbHRlcigoaG91cikgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZEhvdXIgPSByZWZQYXJ0cy5hbXBtID09PSAncG0nID8gKGhvdXIgKyAxMikgJSAyNCA6IGhvdXI7XG4gICAgICAgICAgcmV0dXJuICh1c2UyNEhvdXIgPyBob3VyIDogY29udmVydGVkSG91cikgPj0gbWluUGFydHMuaG91cjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlzQU1BbGxvd2VkID0gbWluUGFydHMuaG91ciA8IDEzO1xuICAgICAgfVxuICAgICAgaWYgKG1pblBhcnRzLm1pbnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWluaW11bSBtaW51dGUgcmFuZ2Ugc2hvdWxkIG5vdCBiZSBlbmZvcmNlZCB3aGVuXG4gICAgICAgICAqIHRoZSBob3VyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWluIGhvdXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBleGFtcGxlIHdpdGggYSBtaW5pbXVtIHJhbmdlIG9mIDA5OjMwLCB1c2Vyc1xuICAgICAgICAgKiBzaG91bGQgYmUgYWJsZSB0byBzZWxlY3QgMTA6MDAtMTA6MjkgYW5kIGJleW9uZC5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBpc1Bhc3RNaW5Ib3VyID0gZmFsc2U7XG4gICAgICAgIGlmIChtaW5QYXJ0cy5ob3VyICE9PSB1bmRlZmluZWQgJiYgcmVmUGFydHMuaG91ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlZlBhcnRzLmhvdXIgPiBtaW5QYXJ0cy5ob3VyKSB7XG4gICAgICAgICAgICBpc1Bhc3RNaW5Ib3VyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc2VkTWludXRlcyA9IHByb2Nlc3NlZE1pbnV0ZXMuZmlsdGVyKChtaW51dGUpID0+IHtcbiAgICAgICAgICBpZiAoaXNQYXN0TWluSG91cikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtaW51dGUgPj0gbWluUGFydHMubWludXRlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogSWYgcmVmIGRheSBpcyBiZWZvcmUgbWluaW11bVxuICAgICAgICogZGF5IGRvIG5vdCByZW5kZXIgYW55IGhvdXJzL21pbnV0ZSB2YWx1ZXNcbiAgICAgICAqL1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0JlZm9yZShyZWZQYXJ0cywgbWluUGFydHMpKSB7XG4gICAgICBwcm9jZXNzZWRIb3VycyA9IFtdO1xuICAgICAgcHJvY2Vzc2VkTWludXRlcyA9IFtdO1xuICAgICAgaXNBTUFsbG93ZWQgPSBpc1BNQWxsb3dlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAobWF4UGFydHMpIHtcbiAgICAvKipcbiAgICAgKiBJZiByZWYgZGF5IGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgICAqIG1heGltdW0gYWxsb3dlZCBkYXksIGZpbHRlciBob3VyL21pbnV0ZVxuICAgICAqIHZhbHVlcyBhY2NvcmRpbmcgdG8gbWF4IGhvdXIgYW5kIG1pbnV0ZS5cbiAgICAgKi9cbiAgICBpZiAoaXNTYW1lRGF5KHJlZlBhcnRzLCBtYXhQYXJ0cykpIHtcbiAgICAgIC8qKlxuICAgICAgICogVXNlcnMgbWF5IG5vdCBhbHdheXMgc2V0IHRoZSBob3VyL21pbnV0ZSBmb3JcbiAgICAgICAqIG1heCB2YWx1ZSAoaS5lLiAyMDIxLTA2LTAyKSBzbyB3ZSBzaG91bGQgYWxsb3dcbiAgICAgICAqIGFsbCBob3Vycy9taW51dGVzIGluIHRoYXQgY2FzZS5cbiAgICAgICAqL1xuICAgICAgaWYgKG1heFBhcnRzLmhvdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9jZXNzZWRIb3VycyA9IHByb2Nlc3NlZEhvdXJzLmZpbHRlcigoaG91cikgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZEhvdXIgPSByZWZQYXJ0cy5hbXBtID09PSAncG0nID8gKGhvdXIgKyAxMikgJSAyNCA6IGhvdXI7XG4gICAgICAgICAgcmV0dXJuICh1c2UyNEhvdXIgPyBob3VyIDogY29udmVydGVkSG91cikgPD0gbWF4UGFydHMuaG91cjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlzUE1BbGxvd2VkID0gbWF4UGFydHMuaG91ciA+PSAxMztcbiAgICAgIH1cbiAgICAgIGlmIChtYXhQYXJ0cy5taW51dGUgIT09IHVuZGVmaW5lZCAmJiByZWZQYXJ0cy5ob3VyID09PSBtYXhQYXJ0cy5ob3VyKSB7XG4gICAgICAgIC8vIFRoZSBhdmFpbGFibGUgbWludXRlcyBzaG91bGQgb25seSBiZSBmaWx0ZXJlZCB3aGVuIHRoZSBob3VyIGlzIHRoZSBzYW1lIGFzIHRoZSBtYXggaG91ci5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGUgaWYgdGhlIG1heCBob3VyIGlzIDEwOjMwIGFuZCB0aGUgY3VycmVudCBob3VyIGlzIDEwOjAwLFxuICAgICAgICAvLyB1c2VycyBzaG91bGQgYmUgYWJsZSB0byBzZWxlY3QgMDAtMzAgbWludXRlcy5cbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgaG91ciBpcyAwOTowMCwgdXNlcnMgc2hvdWxkIGJlIGFibGUgdG8gc2VsZWN0IDAwLTYwIG1pbnV0ZXMuXG4gICAgICAgIHByb2Nlc3NlZE1pbnV0ZXMgPSBwcm9jZXNzZWRNaW51dGVzLmZpbHRlcigobWludXRlKSA9PiBtaW51dGUgPD0gbWF4UGFydHMubWludXRlKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogSWYgcmVmIGRheSBpcyBhZnRlciBtaW5pbXVtXG4gICAgICAgKiBkYXkgZG8gbm90IHJlbmRlciBhbnkgaG91cnMvbWludXRlIHZhbHVlc1xuICAgICAgICovXG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQWZ0ZXIocmVmUGFydHMsIG1heFBhcnRzKSkge1xuICAgICAgcHJvY2Vzc2VkSG91cnMgPSBbXTtcbiAgICAgIHByb2Nlc3NlZE1pbnV0ZXMgPSBbXTtcbiAgICAgIGlzQU1BbGxvd2VkID0gaXNQTUFsbG93ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBob3VyczogcHJvY2Vzc2VkSG91cnMsXG4gICAgbWludXRlczogcHJvY2Vzc2VkTWludXRlcyxcbiAgICBhbTogaXNBTUFsbG93ZWQsXG4gICAgcG06IGlzUE1BbGxvd2VkLFxuICB9O1xufTtcbi8qKlxuICogR2l2ZW4gRGF0ZXRpbWVQYXJ0cywgZ2VuZXJhdGUgdGhlIHByZXZpb3VzLFxuICogY3VycmVudCwgYW5kIGFuZCBuZXh0IG1vbnRocy5cbiAqL1xuY29uc3QgZ2VuZXJhdGVNb250aHMgPSAocmVmUGFydHMpID0+IHtcbiAgcmV0dXJuIFtcbiAgICBnZXRQcmV2aW91c01vbnRoKHJlZlBhcnRzKSxcbiAgICB7IG1vbnRoOiByZWZQYXJ0cy5tb250aCwgeWVhcjogcmVmUGFydHMueWVhciwgZGF5OiByZWZQYXJ0cy5kYXkgfSxcbiAgICBnZXROZXh0TW9udGgocmVmUGFydHMpLFxuICBdO1xufTtcbmNvbnN0IGdldE1vbnRoQ29sdW1uRGF0YSA9IChsb2NhbGUsIHJlZlBhcnRzLCBtaW5QYXJ0cywgbWF4UGFydHMsIG1vbnRoVmFsdWVzLCBmb3JtYXRPcHRpb25zID0ge1xuICBtb250aDogJ2xvbmcnLFxufSkgPT4ge1xuICBjb25zdCB7IHllYXIgfSA9IHJlZlBhcnRzO1xuICBjb25zdCBtb250aHMgPSBbXTtcbiAgaWYgKG1vbnRoVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgcHJvY2Vzc2VkTW9udGhzID0gbW9udGhWYWx1ZXM7XG4gICAgaWYgKChtYXhQYXJ0cyA9PT0gbnVsbCB8fCBtYXhQYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF4UGFydHMubW9udGgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb2Nlc3NlZE1vbnRocyA9IHByb2Nlc3NlZE1vbnRocy5maWx0ZXIoKG1vbnRoKSA9PiBtb250aCA8PSBtYXhQYXJ0cy5tb250aCk7XG4gICAgfVxuICAgIGlmICgobWluUGFydHMgPT09IG51bGwgfHwgbWluUGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1pblBhcnRzLm1vbnRoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9jZXNzZWRNb250aHMgPSBwcm9jZXNzZWRNb250aHMuZmlsdGVyKChtb250aCkgPT4gbW9udGggPj0gbWluUGFydHMubW9udGgpO1xuICAgIH1cbiAgICBwcm9jZXNzZWRNb250aHMuZm9yRWFjaCgocHJvY2Vzc2VkTW9udGgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHtwcm9jZXNzZWRNb250aH0vMS8ke3llYXJ9IEdNVCswMDAwYCk7XG4gICAgICBjb25zdCBtb250aFN0cmluZyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb3JtYXRPcHRpb25zKSwgeyB0aW1lWm9uZTogJ1VUQycgfSkpLmZvcm1hdChkYXRlKTtcbiAgICAgIG1vbnRocy5wdXNoKHsgdGV4dDogbW9udGhTdHJpbmcsIHZhbHVlOiBwcm9jZXNzZWRNb250aCB9KTtcbiAgICB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICBjb25zdCBtYXhNb250aCA9IG1heFBhcnRzICYmIG1heFBhcnRzLnllYXIgPT09IHllYXIgPyBtYXhQYXJ0cy5tb250aCA6IDEyO1xuICAgIGNvbnN0IG1pbk1vbnRoID0gbWluUGFydHMgJiYgbWluUGFydHMueWVhciA9PT0geWVhciA/IG1pblBhcnRzLm1vbnRoIDogMTtcbiAgICBmb3IgKGxldCBpID0gbWluTW9udGg7IGkgPD0gbWF4TW9udGg7IGkrKykge1xuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogVGhlcmUgaXMgYSBidWcgb24gaU9TIDE0IHdoZXJlXG4gICAgICAgKiBJbnRsLkRhdGVUaW1lRm9ybWF0IHRha2VzIGludG8gYWNjb3VudFxuICAgICAgICogdGhlIGxvY2FsIHRpbWV6b25lIG9mZnNldCB3aGVuIGZvcm1hdHRpbmcgZGF0ZXMuXG4gICAgICAgKlxuICAgICAgICogRm9yY2luZyB0aGUgdGltZXpvbmUgdG8gJ1VUQycgZml4ZXMgdGhlIGlzc3VlLiBIb3dldmVyLFxuICAgICAgICogd2Ugc2hvdWxkIGtlZXAgdGhpcyB3b3JrYXJvdW5kIGFzIGl0IGlzIHNhZmVyLiBJbiB0aGUgZXZlbnRcbiAgICAgICAqIHRoaXMgYnJlYWtzIGluIGFub3RoZXIgYnJvd3Nlciwgd2Ugd2lsbCBub3QgYmUgaW1wYWN0ZWRcbiAgICAgICAqIGJlY2F1c2UgYWxsIGRhdGVzIHdpbGwgYmUgaW50ZXJwcmV0ZWQgaW4gVVRDLlxuICAgICAgICpcbiAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgKiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZW4tVVMnLCB7IG1vbnRoOiAnbG9uZycgfSkuZm9ybWF0KG5ldyBEYXRlKCdTYXQgQXByIDAxIDIwMDYgMDA6MDA6MDAgR01ULTA0MDAgKEVEVCknKSkgLy8gXCJNYXJjaFwiXG4gICAgICAgKiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZW4tVVMnLCB7IG1vbnRoOiAnbG9uZycsIHRpbWVab25lOiAnVVRDJyB9KS5mb3JtYXQobmV3IERhdGUoJ1NhdCBBcHIgMDEgMjAwNiAwMDowMDowMCBHTVQtMDQwMCAoRURUKScpKSAvLyBcIkFwcmlsXCJcbiAgICAgICAqXG4gICAgICAgKiBJbiBjZXJ0YWluIHRpbWV6b25lcywgaU9TIDE0IHNob3dzIHRoZSB3cm9uZ1xuICAgICAgICogZGF0ZSBmb3IgLnRvVVRDU3RyaW5nKCkuIFRvIGNvbWJhdCB0aGlzLCB3ZVxuICAgICAgICogZm9yY2UgYWxsIG9mIHRoZSB0aW1lem9uZXMgdG8gR01UKzAwMDAgKFVUQykuXG4gICAgICAgKlxuICAgICAgICogRXhhbXBsZTpcbiAgICAgICAqIFRpbWUgWm9uZTogQ2VudHJhbCBFdXJvcGVhbiBTdGFuZGFyZCBUaW1lXG4gICAgICAgKiBuZXcgRGF0ZSgnMS8xLzE5OTInKS50b1VUQ1N0cmluZygpIC8vIFwiVHVlLCAzMSBEZWMgMTk5MSAyMzowMDowMCBHTVRcIlxuICAgICAgICogbmV3IERhdGUoJzEvMS8xOTkyIEdNVCswMDAwJykudG9VVENTdHJpbmcoKSAvLyBcIldlZCwgMDEgSmFuIDE5OTIgMDA6MDA6MDAgR01UXCJcbiAgICAgICAqL1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke2l9LzEvJHt5ZWFyfSBHTVQrMDAwMGApO1xuICAgICAgY29uc3QgbW9udGhTdHJpbmcgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9ybWF0T3B0aW9ucyksIHsgdGltZVpvbmU6ICdVVEMnIH0pKS5mb3JtYXQoZGF0ZSk7XG4gICAgICBtb250aHMucHVzaCh7IHRleHQ6IG1vbnRoU3RyaW5nLCB2YWx1ZTogaSB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vbnRocztcbn07XG4vKipcbiAqIFJldHVybnMgaW5mb3JtYXRpb24gcmVnYXJkaW5nXG4gKiBzZWxlY3RhYmxlIGRhdGVzIChpLmUgMXN0LCAybmQsIDNyZCwgZXRjKVxuICogd2l0aGluIGEgcmVmZXJlbmNlIG1vbnRoLlxuICogQHBhcmFtIGxvY2FsZSBUaGUgbG9jYWxlIHRvIGZvcm1hdCB0aGUgZGF0ZSB3aXRoXG4gKiBAcGFyYW0gcmVmUGFydHMgVGhlIHJlZmVyZW5jZSBtb250aC95ZWFyIHRvIGdlbmVyYXRlIGRhdGVzIGZvclxuICogQHBhcmFtIG1pblBhcnRzIFRoZSBtaW5pbXVtIGJvdW5kIG9uIHRoZSBkYXRlIHRoYXQgY2FuIGJlIHJldHVybmVkXG4gKiBAcGFyYW0gbWF4UGFydHMgVGhlIG1heGltdW0gYm91bmQgb24gdGhlIGRhdGUgdGhhdCBjYW4gYmUgcmV0dXJuZWRcbiAqIEBwYXJhbSBkYXlWYWx1ZXMgVGhlIGFsbG93ZWQgZGF0ZSB2YWx1ZXNcbiAqIEByZXR1cm5zIERhdGUgZGF0YSB0byBiZSB1c2VkIGluIGlvbi1waWNrZXItY29sdW1uLWludGVybmFsXG4gKi9cbmNvbnN0IGdldERheUNvbHVtbkRhdGEgPSAobG9jYWxlLCByZWZQYXJ0cywgbWluUGFydHMsIG1heFBhcnRzLCBkYXlWYWx1ZXMsIGZvcm1hdE9wdGlvbnMgPSB7XG4gIGRheTogJ251bWVyaWMnLFxufSkgPT4ge1xuICBjb25zdCB7IG1vbnRoLCB5ZWFyIH0gPSByZWZQYXJ0cztcbiAgY29uc3QgZGF5cyA9IFtdO1xuICAvKipcbiAgICogSWYgd2UgaGF2ZSBtYXgvbWluIGJvdW5kcyB0aGF0IGluIHRoZSBzYW1lXG4gICAqIG1vbnRoL3llYXIgYXMgdGhlIHJlZlBhcnRzLCB3ZSBzaG91bGRcbiAgICogdXNlIHRoZSBkZWZpbmUgZGF5IGFzIHRoZSBtYXgvbWluIGRheS5cbiAgICogT3RoZXJ3aXNlLCBmYWxsYmFjayB0byB0aGUgbWF4L21pbiBkYXlzIGluIGEgbW9udGguXG4gICAqL1xuICBjb25zdCBudW1EYXlzSW5Nb250aCA9IGdldE51bURheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcbiAgY29uc3QgbWF4RGF5ID0gKG1heFBhcnRzID09PSBudWxsIHx8IG1heFBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXhQYXJ0cy5kYXkpICYmIG1heFBhcnRzLnllYXIgPT09IHllYXIgJiYgbWF4UGFydHMubW9udGggPT09IG1vbnRoID8gbWF4UGFydHMuZGF5IDogbnVtRGF5c0luTW9udGg7XG4gIGNvbnN0IG1pbkRheSA9IChtaW5QYXJ0cyA9PT0gbnVsbCB8fCBtaW5QYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWluUGFydHMuZGF5KSAmJiBtaW5QYXJ0cy55ZWFyID09PSB5ZWFyICYmIG1pblBhcnRzLm1vbnRoID09PSBtb250aCA/IG1pblBhcnRzLmRheSA6IDE7XG4gIGlmIChkYXlWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBwcm9jZXNzZWREYXlzID0gZGF5VmFsdWVzO1xuICAgIHByb2Nlc3NlZERheXMgPSBwcm9jZXNzZWREYXlzLmZpbHRlcigoZGF5KSA9PiBkYXkgPj0gbWluRGF5ICYmIGRheSA8PSBtYXhEYXkpO1xuICAgIHByb2Nlc3NlZERheXMuZm9yRWFjaCgocHJvY2Vzc2VkRGF5KSA9PiB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoYCR7bW9udGh9LyR7cHJvY2Vzc2VkRGF5fS8ke3llYXJ9IEdNVCswMDAwYCk7XG4gICAgICBjb25zdCBkYXlTdHJpbmcgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9ybWF0T3B0aW9ucyksIHsgdGltZVpvbmU6ICdVVEMnIH0pKS5mb3JtYXQoZGF0ZSk7XG4gICAgICBkYXlzLnB1c2goeyB0ZXh0OiBkYXlTdHJpbmcsIHZhbHVlOiBwcm9jZXNzZWREYXkgfSk7XG4gICAgfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IG1pbkRheTsgaSA8PSBtYXhEYXk7IGkrKykge1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke21vbnRofS8ke2l9LyR7eWVhcn0gR01UKzAwMDBgKTtcbiAgICAgIGNvbnN0IGRheVN0cmluZyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb3JtYXRPcHRpb25zKSwgeyB0aW1lWm9uZTogJ1VUQycgfSkpLmZvcm1hdChkYXRlKTtcbiAgICAgIGRheXMucHVzaCh7IHRleHQ6IGRheVN0cmluZywgdmFsdWU6IGkgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXlzO1xufTtcbmNvbnN0IGdldFllYXJDb2x1bW5EYXRhID0gKHJlZlBhcnRzLCBtaW5QYXJ0cywgbWF4UGFydHMsIHllYXJWYWx1ZXMpID0+IHtcbiAgbGV0IHByb2Nlc3NlZFllYXJzID0gW107XG4gIGlmICh5ZWFyVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBwcm9jZXNzZWRZZWFycyA9IHllYXJWYWx1ZXM7XG4gICAgaWYgKChtYXhQYXJ0cyA9PT0gbnVsbCB8fCBtYXhQYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF4UGFydHMueWVhcikgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvY2Vzc2VkWWVhcnMgPSBwcm9jZXNzZWRZZWFycy5maWx0ZXIoKHllYXIpID0+IHllYXIgPD0gbWF4UGFydHMueWVhcik7XG4gICAgfVxuICAgIGlmICgobWluUGFydHMgPT09IG51bGwgfHwgbWluUGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1pblBhcnRzLnllYXIpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb2Nlc3NlZFllYXJzID0gcHJvY2Vzc2VkWWVhcnMuZmlsdGVyKCh5ZWFyKSA9PiB5ZWFyID49IG1pblBhcnRzLnllYXIpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBjb25zdCB7IHllYXIgfSA9IHJlZlBhcnRzO1xuICAgIGNvbnN0IG1heFllYXIgPSAobWF4UGFydHMgPT09IG51bGwgfHwgbWF4UGFydHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heFBhcnRzLnllYXIpIHx8IHllYXI7XG4gICAgY29uc3QgbWluWWVhciA9IChtaW5QYXJ0cyA9PT0gbnVsbCB8fCBtaW5QYXJ0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWluUGFydHMueWVhcikgfHwgeWVhciAtIDEwMDtcbiAgICBmb3IgKGxldCBpID0gbWF4WWVhcjsgaSA+PSBtaW5ZZWFyOyBpLS0pIHtcbiAgICAgIHByb2Nlc3NlZFllYXJzLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9jZXNzZWRZZWFycy5tYXAoKHllYXIpID0+ICh7XG4gICAgdGV4dDogYCR7eWVhcn1gLFxuICAgIHZhbHVlOiB5ZWFyLFxuICB9KSk7XG59O1xuLyoqXG4gKiBHaXZlbiBhIHN0YXJ0aW5nIGRhdGUgYW5kIGFuIHVwcGVyIGJvdW5kLFxuICogdGhpcyBmdW5jdGlvbnMgcmV0dXJucyBhbiBhcnJheSBvZiBhbGxcbiAqIG1vbnRoIG9iamVjdHMgaW4gdGhhdCByYW5nZS5cbiAqL1xuY29uc3QgZ2V0QWxsTW9udGhzSW5SYW5nZSA9IChjdXJyZW50UGFydHMsIG1heFBhcnRzKSA9PiB7XG4gIGlmIChjdXJyZW50UGFydHMubW9udGggPT09IG1heFBhcnRzLm1vbnRoICYmIGN1cnJlbnRQYXJ0cy55ZWFyID09PSBtYXhQYXJ0cy55ZWFyKSB7XG4gICAgcmV0dXJuIFtjdXJyZW50UGFydHNdO1xuICB9XG4gIHJldHVybiBbY3VycmVudFBhcnRzLCAuLi5nZXRBbGxNb250aHNJblJhbmdlKGdldE5leHRNb250aChjdXJyZW50UGFydHMpLCBtYXhQYXJ0cyldO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBwaWNrZXIgaXRlbXNcbiAqIHRoYXQgcmVwcmVzZW50IHRoZSBkYXlzIGluIGEgbW9udGguXG4gKiBFeGFtcGxlOiBcIlRodSwgSnVuIDJcIlxuICovXG5jb25zdCBnZXRDb21iaW5lZERhdGVDb2x1bW5EYXRhID0gKGxvY2FsZSwgcmVmUGFydHMsIHRvZGF5UGFydHMsIG1pblBhcnRzLCBtYXhQYXJ0cywgZGF5VmFsdWVzLCBtb250aFZhbHVlcykgPT4ge1xuICBsZXQgaXRlbXMgPSBbXTtcbiAgbGV0IHBhcnRzID0gW107XG4gIC8qKlxuICAgKiBHZXQgYWxsIG1vbnRoIG9iamVjdHMgZnJvbSB0aGUgbWluIGRhdGVcbiAgICogdG8gdGhlIG1heCBkYXRlLiBOb3RlOiBEbyBub3QgdXNlIGdldE1vbnRoQ29sdW1uRGF0YVxuICAgKiBhcyB0aGF0IGZ1bmN0aW9uIG9ubHkgZ2VuZXJhdGVzIGRhdGVzIHdpdGhpbiBhXG4gICAqIHNpbmdsZSB5ZWFyLlxuICAgKi9cbiAgbGV0IG1vbnRocyA9IGdldEFsbE1vbnRoc0luUmFuZ2UobWluUGFydHMsIG1heFBhcnRzKTtcbiAgLyoqXG4gICAqIEZpbHRlciBvdXQgYW55IGRpc2FsbG93ZWQgbW9udGggdmFsdWVzLlxuICAgKi9cbiAgaWYgKG1vbnRoVmFsdWVzKSB7XG4gICAgbW9udGhzID0gbW9udGhzLmZpbHRlcigoeyBtb250aCB9KSA9PiBtb250aFZhbHVlcy5pbmNsdWRlcyhtb250aCkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIG9mIHRoZSBkYXlzIGluIHRoZSBtb250aC5cbiAgICogRnJvbSB0aGVyZSwgZ2VuZXJhdGUgYW4gYXJyYXkgd2hlcmVcbiAgICogZWFjaCBpdGVtIGhhcyB0aGUgbW9udGgsIGRhdGUsIGFuZCBkYXlcbiAgICogb2Ygd29yayBhcyB0aGUgdGV4dC5cbiAgICovXG4gIG1vbnRocy5mb3JFYWNoKChtb250aE9iamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlZmVyZW5jZU1vbnRoID0geyBtb250aDogbW9udGhPYmplY3QubW9udGgsIGRheTogbnVsbCwgeWVhcjogcmVmUGFydHMueWVhciB9O1xuICAgIGNvbnN0IG1vbnRoRGF5cyA9IGdldERheUNvbHVtbkRhdGEobG9jYWxlLCByZWZlcmVuY2VNb250aCwgbWluUGFydHMsIG1heFBhcnRzLCBkYXlWYWx1ZXMsIHtcbiAgICAgIG1vbnRoOiAnc2hvcnQnLFxuICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICB3ZWVrZGF5OiAnc2hvcnQnLFxuICAgIH0pO1xuICAgIGNvbnN0IGRhdGVQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IGRhdGVDb2x1bW5JdGVtcyA9IFtdO1xuICAgIG1vbnRoRGF5cy5mb3JFYWNoKChkYXlPYmplY3QpID0+IHtcbiAgICAgIGNvbnN0IGlzVG9kYXkgPSBpc1NhbWVEYXkoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWZlcmVuY2VNb250aCksIHsgZGF5OiBkYXlPYmplY3QudmFsdWUgfSksIHRvZGF5UGFydHMpO1xuICAgICAgLyoqXG4gICAgICAgKiBUb2RheSdzIGRhdGUgc2hvdWxkIHJlYWQgYXMgXCJUb2RheVwiIChsb2NhbGl6ZWQpXG4gICAgICAgKiBub3QgdGhlIGFjdHVhbCBkYXRlIHN0cmluZ1xuICAgICAgICovXG4gICAgICBkYXRlQ29sdW1uSXRlbXMucHVzaCh7XG4gICAgICAgIHRleHQ6IGlzVG9kYXkgPyBnZXRUb2RheUxhYmVsKGxvY2FsZSkgOiBkYXlPYmplY3QudGV4dCxcbiAgICAgICAgdmFsdWU6IGAke3JlZlBhcnRzLnllYXJ9LSR7bW9udGhPYmplY3QubW9udGh9LSR7ZGF5T2JqZWN0LnZhbHVlfWAsXG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogV2hlbiBzZWxlY3RpbmcgYSBkYXRlIGluIHRoZSB3aGVlbCBwaWNrZXJcbiAgICAgICAqIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSByYXcgZGF0ZXRpbWUgcGFydHMgZGF0YS5cbiAgICAgICAqIFRoZSBwaWNrZXIgY29sdW1uIG9ubHkgYWNjZXB0cyB2YWx1ZXMgb2ZcbiAgICAgICAqIHR5cGUgc3RyaW5nIG9yIG51bWJlciwgc28gd2UgbmVlZCB0byByZXR1cm5cbiAgICAgICAqIHR3byBzZXRzIG9mIGRhdGE6IEEgZGF0YSBzZXQgdG8gYmUgcGFzc2VkXG4gICAgICAgKiB0byB0aGUgcGlja2VyIGNvbHVtbiwgYW5kIGEgZGF0YSBzZXQgdG9cbiAgICAgICAqIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSByYXcgZGF0YSB3aGVuXG4gICAgICAgKiB1cGRhdGluZyB0aGUgcGlja2VyIGNvbHVtbiB2YWx1ZS5cbiAgICAgICAqL1xuICAgICAgZGF0ZVBhcnRzLnB1c2goe1xuICAgICAgICBtb250aDogbW9udGhPYmplY3QubW9udGgsXG4gICAgICAgIHllYXI6IHJlZlBhcnRzLnllYXIsXG4gICAgICAgIGRheTogZGF5T2JqZWN0LnZhbHVlLFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcGFydHMgPSBbLi4ucGFydHMsIC4uLmRhdGVQYXJ0c107XG4gICAgaXRlbXMgPSBbLi4uaXRlbXMsIC4uLmRhdGVDb2x1bW5JdGVtc107XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHBhcnRzLFxuICAgIGl0ZW1zLFxuICB9O1xufTtcbmNvbnN0IGdldFRpbWVDb2x1bW5zRGF0YSA9IChsb2NhbGUsIHJlZlBhcnRzLCBob3VyQ3ljbGUsIG1pblBhcnRzLCBtYXhQYXJ0cywgYWxsb3dlZEhvdXJWYWx1ZXMsIGFsbG93ZWRNaW51dGVWYXVlcykgPT4ge1xuICBjb25zdCB1c2UyNEhvdXIgPSBpczI0SG91cihsb2NhbGUsIGhvdXJDeWNsZSk7XG4gIGNvbnN0IHsgaG91cnMsIG1pbnV0ZXMsIGFtLCBwbSB9ID0gZ2VuZXJhdGVUaW1lKHJlZlBhcnRzLCB1c2UyNEhvdXIgPyAnaDIzJyA6ICdoMTInLCBtaW5QYXJ0cywgbWF4UGFydHMsIGFsbG93ZWRIb3VyVmFsdWVzLCBhbGxvd2VkTWludXRlVmF1ZXMpO1xuICBjb25zdCBob3Vyc0l0ZW1zID0gaG91cnMubWFwKChob3VyKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IGdldEZvcm1hdHRlZEhvdXIoaG91ciwgdXNlMjRIb3VyKSxcbiAgICAgIHZhbHVlOiBnZXRJbnRlcm5hbEhvdXJWYWx1ZShob3VyLCB1c2UyNEhvdXIsIHJlZlBhcnRzLmFtcG0pLFxuICAgIH07XG4gIH0pO1xuICBjb25zdCBtaW51dGVzSXRlbXMgPSBtaW51dGVzLm1hcCgobWludXRlKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IGFkZFRpbWVQYWRkaW5nKG1pbnV0ZSksXG4gICAgICB2YWx1ZTogbWludXRlLFxuICAgIH07XG4gIH0pO1xuICBjb25zdCBkYXlQZXJpb2RJdGVtcyA9IFtdO1xuICBpZiAoYW0gJiYgIXVzZTI0SG91cikge1xuICAgIGRheVBlcmlvZEl0ZW1zLnB1c2goe1xuICAgICAgdGV4dDogZ2V0TG9jYWxpemVkRGF5UGVyaW9kKGxvY2FsZSwgJ2FtJyksXG4gICAgICB2YWx1ZTogJ2FtJyxcbiAgICB9KTtcbiAgfVxuICBpZiAocG0gJiYgIXVzZTI0SG91cikge1xuICAgIGRheVBlcmlvZEl0ZW1zLnB1c2goe1xuICAgICAgdGV4dDogZ2V0TG9jYWxpemVkRGF5UGVyaW9kKGxvY2FsZSwgJ3BtJyksXG4gICAgICB2YWx1ZTogJ3BtJyxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1pbnV0ZXNEYXRhOiBtaW51dGVzSXRlbXMsXG4gICAgaG91cnNEYXRhOiBob3Vyc0l0ZW1zLFxuICAgIGRheVBlcmlvZERhdGE6IGRheVBlcmlvZEl0ZW1zLFxuICB9O1xufTtcblxuY29uc3QgSVNPXzg2MDFfUkVHRVhQID0gXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbi9eKFxcZHs0fXxbK1xcLV1cXGR7Nn0pKD86LShcXGR7Mn0pKD86LShcXGR7Mn0pKT8pPyg/OlQoXFxkezJ9KTooXFxkezJ9KSg/OjooXFxkezJ9KSg/OlxcLihcXGR7M30pKT8pPyg/OihaKXwoWytcXC1dKShcXGR7Mn0pKD86OihcXGR7Mn0pKT8pPyk/JC87XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbmNvbnN0IFRJTUVfUkVHRVhQID0gL14oKFxcZHsyfSk6KFxcZHsyfSkoPzo6KFxcZHsyfSkoPzpcXC4oXFxkezN9KSk/KT8oPzooWil8KFsrXFwtXSkoXFxkezJ9KSg/OjooXFxkezJ9KSk/KT8pPyQvO1xuLyoqXG4gKiBVc2UgdG8gY29udmVydCBhIHN0cmluZyBvZiBjb21tYSBzZXBhcmF0ZWQgbnVtYmVycyBvclxuICogYW4gYXJyYXkgb2YgbnVtYmVycywgYW5kIGNsZWFuIHVwIGFueSB1c2VyIGlucHV0XG4gKi9cbmNvbnN0IGNvbnZlcnRUb0FycmF5T2ZOdW1iZXJzID0gKGlucHV0KSA9PiB7XG4gIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBwcm9jZXNzZWRJbnB1dCA9IGlucHV0O1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGNvbnZlcnQgdGhlIHN0cmluZyB0byBhbiBhcnJheSBvZiBzdHJpbmdzXG4gICAgLy8gYXV0byByZW1vdmUgYW55IHdoaXRlc3BhY2UgYW5kIFtdIGNoYXJhY3RlcnNcbiAgICBwcm9jZXNzZWRJbnB1dCA9IGlucHV0LnJlcGxhY2UoL1xcW3xcXF18XFxzL2csICcnKS5zcGxpdCgnLCcpO1xuICB9XG4gIGxldCB2YWx1ZXM7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb2Nlc3NlZElucHV0KSkge1xuICAgIC8vIGVuc3VyZSBlYWNoIHZhbHVlIGlzIGFuIGFjdHVhbCBudW1iZXIgaW4gdGhlIHJldHVybmVkIGFycmF5XG4gICAgdmFsdWVzID0gcHJvY2Vzc2VkSW5wdXQubWFwKChudW0pID0+IHBhcnNlSW50KG51bSwgMTApKS5maWx0ZXIoaXNGaW5pdGUpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhbHVlcyA9IFtwcm9jZXNzZWRJbnB1dF07XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn07XG4vKipcbiAqIEV4dHJhY3RzIGRhdGUgaW5mb3JtYXRpb25cbiAqIGZyb20gYSAuY2FsZW5kYXItZGF5IGVsZW1lbnRcbiAqIGludG8gRGF0ZXRpbWVQYXJ0cy5cbiAqL1xuY29uc3QgZ2V0UGFydHNGcm9tQ2FsZW5kYXJEYXkgPSAoZWwpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBtb250aDogcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLW1vbnRoJyksIDEwKSxcbiAgICBkYXk6IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kYXknKSwgMTApLFxuICAgIHllYXI6IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS15ZWFyJyksIDEwKSxcbiAgICBkYXlPZldlZWs6IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kYXktb2Ytd2VlaycpLCAxMCksXG4gIH07XG59O1xuZnVuY3Rpb24gcGFyc2VEYXRlKHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbC5tYXAoKHZhbFN0cikgPT4gcGFyc2VEYXRlKHZhbFN0cikpO1xuICB9XG4gIC8vIG1hbnVhbGx5IHBhcnNlIElTMCBjdXogRGF0ZS5wYXJzZSBjYW5ub3QgYmUgdHJ1c3RlZFxuICAvLyBJU08gODYwMSBmb3JtYXQ6IDE5OTQtMTItMTVUMTM6NDc6MjBaXG4gIGxldCBwYXJzZSA9IG51bGw7XG4gIGlmICh2YWwgIT0gbnVsbCAmJiB2YWwgIT09ICcnKSB7XG4gICAgLy8gdHJ5IHBhcnNpbmcgZm9yIGp1c3QgdGltZSBmaXJzdCwgSEg6TU1cbiAgICBwYXJzZSA9IFRJTUVfUkVHRVhQLmV4ZWModmFsKTtcbiAgICBpZiAocGFyc2UpIHtcbiAgICAgIC8vIGFkanVzdCB0aGUgYXJyYXkgc28gaXQgZml0cyBuaWNlbHkgd2l0aCB0aGUgZGF0ZXRpbWUgcGFyc2VcbiAgICAgIHBhcnNlLnVuc2hpZnQodW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgcGFyc2VbMl0gPSBwYXJzZVszXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyB0cnkgcGFyc2luZyBmb3IgZnVsbCBJU08gZGF0ZXRpbWVcbiAgICAgIHBhcnNlID0gSVNPXzg2MDFfUkVHRVhQLmV4ZWModmFsKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcnNlID09PSBudWxsKSB7XG4gICAgLy8gd2Fzbid0IGFibGUgdG8gcGFyc2UgdGhlIElTTyBkYXRldGltZVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgLy8gZW5zdXJlIGFsbCB0aGUgcGFyc2UgdmFsdWVzIGV4aXN0IHdpdGggYXQgbGVhc3QgMFxuICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgIHBhcnNlW2ldID0gcGFyc2VbaV0gIT09IHVuZGVmaW5lZCA/IHBhcnNlSW50KHBhcnNlW2ldLCAxMCkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgbGV0IHR6T2Zmc2V0ID0gMDtcbiAgaWYgKHBhcnNlWzldICYmIHBhcnNlWzEwXSkge1xuICAgIC8vIGhvdXJzXG4gICAgdHpPZmZzZXQgPSBwYXJzZUludChwYXJzZVsxMF0sIDEwKSAqIDYwO1xuICAgIGlmIChwYXJzZVsxMV0pIHtcbiAgICAgIC8vIG1pbnV0ZXNcbiAgICAgIHR6T2Zmc2V0ICs9IHBhcnNlSW50KHBhcnNlWzExXSwgMTApO1xuICAgIH1cbiAgICBpZiAocGFyc2VbOV0gPT09ICctJykge1xuICAgICAgLy8gKyBvciAtXG4gICAgICB0ek9mZnNldCAqPSAtMTtcbiAgICB9XG4gIH1cbiAgLy8gY2FuIGFsc28gZ2V0IHNlY29uZCBhbmQgbWlsbGlzZWNvbmQgZnJvbSBwYXJzZVs2XSBhbmQgcGFyc2VbN10gaWYgbmVlZGVkXG4gIHJldHVybiB7XG4gICAgeWVhcjogcGFyc2VbMV0sXG4gICAgbW9udGg6IHBhcnNlWzJdLFxuICAgIGRheTogcGFyc2VbM10sXG4gICAgaG91cjogcGFyc2VbNF0sXG4gICAgbWludXRlOiBwYXJzZVs1XSxcbiAgICB0ek9mZnNldCxcbiAgfTtcbn1cbmNvbnN0IGNsYW1wRGF0ZSA9IChkYXRlUGFydHMsIG1pblBhcnRzLCBtYXhQYXJ0cykgPT4ge1xuICBpZiAobWluUGFydHMgJiYgaXNCZWZvcmUoZGF0ZVBhcnRzLCBtaW5QYXJ0cykpIHtcbiAgICByZXR1cm4gbWluUGFydHM7XG4gIH1cbiAgZWxzZSBpZiAobWF4UGFydHMgJiYgaXNBZnRlcihkYXRlUGFydHMsIG1heFBhcnRzKSkge1xuICAgIHJldHVybiBtYXhQYXJ0cztcbiAgfVxuICByZXR1cm4gZGF0ZVBhcnRzO1xufTtcbi8qKlxuICogUGFyc2VzIGFuIGhvdXIgYW5kIHJldHVybnMgaWYgdGhlIHZhbHVlIGlzIGluIHRoZSBtb3JuaW5nIChhbSkgb3IgYWZ0ZXJub29uIChwbSkuXG4gKiBAcGFyYW0gaG91ciBUaGUgaG91ciB0byBmb3JtYXQsIHNob3VsZCBiZSAwLTIzXG4gKiBAcmV0dXJucyBgcG1gIGlmIHRoZSBob3VyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxMiwgYGFtYCBpZiBsZXNzIHRoYW4gMTIuXG4gKi9cbmNvbnN0IHBhcnNlQW1QbSA9IChob3VyKSA9PiB7XG4gIHJldHVybiBob3VyID49IDEyID8gJ3BtJyA6ICdhbSc7XG59O1xuXG5leHBvcnQgeyBnZXRNb250aEFuZFllYXIgYXMgQSwgZ2V0RGF5c09mTW9udGggYXMgQiwgZ2VuZXJhdGVNb250aHMgYXMgQywgaXMyNEhvdXIgYXMgRCwgZ2V0TG9jYWxpemVkVGltZSBhcyBFLCBnZXRNb250aEFuZERheSBhcyBGLCBmb3JtYXRWYWx1ZSBhcyBHLCBnZXROZXh0WWVhciBhcyBILCBnZXRQcmV2aW91c1llYXIgYXMgSSwgY2xhbXBEYXRlIGFzIEosIHBhcnNlQW1QbSBhcyBLLCBjYWxjdWxhdGVIb3VyRnJvbUFNUE0gYXMgTCwgZ2V0TG9jYWxpemVkRGF0ZVRpbWUgYXMgTSwgZ2V0TW9udGhEYXlBbmRZZWFyIGFzIE4sIGlzQWZ0ZXIgYXMgYSwgaXNTYW1lRGF5IGFzIGIsIGdldFByZXZpb3VzTW9udGggYXMgYywgZ2V0TmV4dE1vbnRoIGFzIGQsIGdldFRvZGF5IGFzIGUsIGdldFBhcnRzRnJvbUNhbGVuZGFyRGF5IGFzIGYsIGdlbmVyYXRlRGF5QXJpYUxhYmVsIGFzIGcsIGdldEVuZE9mV2VlayBhcyBoLCBpc0JlZm9yZSBhcyBpLCBnZXRTdGFydE9mV2VlayBhcyBqLCBnZXRQcmV2aW91c0RheSBhcyBrLCBnZXROZXh0RGF5IGFzIGwsIGdldFByZXZpb3VzV2VlayBhcyBtLCBnZXROZXh0V2VlayBhcyBuLCBjb252ZXJ0VG9BcnJheU9mTnVtYmVycyBhcyBvLCBwYXJzZURhdGUgYXMgcCwgY29udmVydERhdGFUb0lTTyBhcyBxLCBnZXRDb21iaW5lZERhdGVDb2x1bW5EYXRhIGFzIHIsIGdldE1vbnRoQ29sdW1uRGF0YSBhcyBzLCBnZXREYXlDb2x1bW5EYXRhIGFzIHQsIGdldFllYXJDb2x1bW5EYXRhIGFzIHUsIGlzTW9udGhGaXJzdExvY2FsZSBhcyB2LCB3YXJuSWZWYWx1ZU91dE9mQm91bmRzIGFzIHcsIGdldFRpbWVDb2x1bW5zRGF0YSBhcyB4LCBpc0xvY2FsZURheVBlcmlvZFJUTCBhcyB5LCBnZXREYXlzT2ZXZWVrIGFzIHogfTtcbiIsIi8qIVxuICogKEMpIElvbmljIGh0dHA6Ly9pb25pY2ZyYW1ld29yay5jb20gLSBNSVQgTGljZW5zZVxuICovXG5jb25zdCBob3N0Q29udGV4dCA9IChzZWxlY3RvciwgZWwpID0+IHtcbiAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpICE9PSBudWxsO1xufTtcbi8qKlxuICogQ3JlYXRlIHRoZSBtb2RlIGFuZCBjb2xvciBjbGFzc2VzIGZvciB0aGUgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBjbGFzc2VzIHBhc3NlZCBpblxuICovXG5jb25zdCBjcmVhdGVDb2xvckNsYXNzZXMgPSAoY29sb3IsIGNzc0NsYXNzTWFwKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnICYmIGNvbG9yLmxlbmd0aCA+IDBcbiAgICA/IE9iamVjdC5hc3NpZ24oeyAnaW9uLWNvbG9yJzogdHJ1ZSwgW2Bpb24tY29sb3ItJHtjb2xvcn1gXTogdHJ1ZSB9LCBjc3NDbGFzc01hcCkgOiBjc3NDbGFzc01hcDtcbn07XG5jb25zdCBnZXRDbGFzc0xpc3QgPSAoY2xhc3NlcykgPT4ge1xuICBpZiAoY2xhc3NlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5pc0FycmF5KGNsYXNzZXMpID8gY2xhc3NlcyA6IGNsYXNzZXMuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4gYXJyYXlcbiAgICAgIC5maWx0ZXIoKGMpID0+IGMgIT0gbnVsbClcbiAgICAgIC5tYXAoKGMpID0+IGMudHJpbSgpKVxuICAgICAgLmZpbHRlcigoYykgPT4gYyAhPT0gJycpO1xuICB9XG4gIHJldHVybiBbXTtcbn07XG5jb25zdCBnZXRDbGFzc01hcCA9IChjbGFzc2VzKSA9PiB7XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBnZXRDbGFzc0xpc3QoY2xhc3NlcykuZm9yRWFjaCgoYykgPT4gKG1hcFtjXSA9IHRydWUpKTtcbiAgcmV0dXJuIG1hcDtcbn07XG5jb25zdCBTQ0hFTUUgPSAvXlthLXpdW2EtejAtOStcXC0uXSo6LztcbmNvbnN0IG9wZW5VUkwgPSBhc3luYyAodXJsLCBldiwgZGlyZWN0aW9uLCBhbmltYXRpb24pID0+IHtcbiAgaWYgKHVybCAhPSBudWxsICYmIHVybFswXSAhPT0gJyMnICYmICFTQ0hFTUUudGVzdCh1cmwpKSB7XG4gICAgY29uc3Qgcm91dGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW9uLXJvdXRlcicpO1xuICAgIGlmIChyb3V0ZXIpIHtcbiAgICAgIGlmIChldiAhPSBudWxsKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm91dGVyLnB1c2godXJsLCBkaXJlY3Rpb24sIGFuaW1hdGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZUNvbG9yQ2xhc3NlcyBhcyBjLCBnZXRDbGFzc01hcCBhcyBnLCBob3N0Q29udGV4dCBhcyBoLCBvcGVuVVJMIGFzIG8gfTtcbiJdLCJuYW1lcyI6WyJwcmludElvbldhcm5pbmciLCJtZXNzYWdlIiwicGFyYW1zIiwiY29uc29sZSIsIndhcm4iLCJwcmludElvbkVycm9yIiwiZXJyb3IiLCJwcmludFJlcXVpcmVkRWxlbWVudEVycm9yIiwiZWwiLCJ0YXJnZXRTZWxlY3RvcnMiLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJqb2luIiwiYSIsImIiLCJwIiwiaXNTYW1lRGF5IiwiYmFzZVBhcnRzIiwiY29tcGFyZVBhcnRzIiwibW9udGgiLCJkYXkiLCJ5ZWFyIiwiaXNCZWZvcmUiLCJpc0FmdGVyIiwid2FybklmVmFsdWVPdXRPZkJvdW5kcyIsInZhbHVlIiwibWluIiwibWF4IiwidmFsdWVBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsInZhbCIsIkpTT04iLCJzdHJpbmdpZnkiLCJpc0xlYXBZZWFyIiwiaXMyNEhvdXIiLCJsb2NhbGUiLCJob3VyQ3ljbGUiLCJ1bmRlZmluZWQiLCJmb3JtYXR0ZWQiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJob3VyIiwib3B0aW9ucyIsInJlc29sdmVkT3B0aW9ucyIsImRhdGUiLCJEYXRlIiwicGFydHMiLCJmb3JtYXRUb1BhcnRzIiwiZmluZCIsInR5cGUiLCJFcnJvciIsImdldE51bURheXNJbk1vbnRoIiwiaXNNb250aEZpcnN0TG9jYWxlIiwiZm9ybWF0T3B0aW9ucyIsImlzTG9jYWxlRGF5UGVyaW9kUlRMIiwidHdvRGlnaXQiLCJNYXRoIiwiYWJzIiwic2xpY2UiLCJmb3VyRGlnaXQiLCJjb252ZXJ0RGF0YVRvSVNPIiwiZGF0YSIsIm1hcCIsInJ0biIsIm1pbnV0ZSIsInR6T2Zmc2V0IiwiZmxvb3IiLCJjb252ZXJ0MTJIb3VyVG8yNEhvdXIiLCJhbXBtIiwiZ2V0U3RhcnRPZldlZWsiLCJyZWZQYXJ0cyIsImRheU9mV2VlayIsInN1YnRyYWN0RGF5cyIsImdldEVuZE9mV2VlayIsImFkZERheXMiLCJnZXROZXh0RGF5IiwiZ2V0UHJldmlvdXNEYXkiLCJnZXRQcmV2aW91c1dlZWsiLCJnZXROZXh0V2VlayIsIm51bURheXMiLCJ3b3JraW5nUGFydHMiLCJkYXlzSW5Nb250aCIsImdldFByZXZpb3VzTW9udGgiLCJudW1EYXlzSW5Nb250aCIsImdldE5leHRNb250aCIsImNoYW5nZVllYXIiLCJ5ZWFyRGVsdGEiLCJnZXRQcmV2aW91c1llYXIiLCJnZXROZXh0WWVhciIsImdldEludGVybmFsSG91clZhbHVlIiwidXNlMjRIb3VyIiwiY2FsY3VsYXRlSG91ckZyb21BTVBNIiwiY3VycmVudFBhcnRzIiwibmV3QU1QTSIsImN1cnJlbnRBTVBNIiwibmV3SG91ciIsImdldEZvcm1hdHRlZERheVBlcmlvZCIsImRheVBlcmlvZCIsInRvVXBwZXJDYXNlIiwiZ2V0TG9jYWxpemVkVGltZSIsInRpbWVab25lIiwiaG91cjEyIiwiZm9ybWF0IiwiT2JqZWN0IiwiYXNzaWduIiwiYWRkVGltZVBhZGRpbmciLCJ2YWx1ZVRvU3RyaW5nIiwidG9TdHJpbmciLCJsZW5ndGgiLCJnZXRGb3JtYXR0ZWRIb3VyIiwiZ2VuZXJhdGVEYXlBcmlhTGFiZWwiLCJ0b2RheSIsImxhYmVsU3RyaW5nIiwid2Vla2RheSIsImdldE1vbnRoQW5kRGF5IiwiZ2V0TW9udGhBbmRZZWFyIiwiZ2V0TW9udGhEYXlBbmRZZWFyIiwiZ2V0TG9jYWxpemVkRGF0ZVRpbWUiLCJ0aW1lU3RyaW5nIiwiZ2V0VG9kYXlMYWJlbCIsImxhYmVsIiwiUmVsYXRpdmVUaW1lRm9ybWF0IiwibnVtZXJpYyIsImNoYXJBdCIsInJlbW92ZURhdGVUek9mZnNldCIsImdldFRpbWV6b25lT2Zmc2V0Iiwic2V0TWludXRlcyIsImdldE1pbnV0ZXMiLCJEQVRFX0FNIiwiREFURV9QTSIsImdldExvY2FsaXplZERheVBlcmlvZCIsImxvY2FsaXplZERheVBlcmlvZCIsInBhcnQiLCJmb3JtYXRWYWx1ZSIsImdldFRvZGF5IiwidG9JU09TdHJpbmciLCJtaW51dGVzIiwiaG91cjIzIiwiZ2V0RGF5c09mV2VlayIsIm1vZGUiLCJmaXJzdERheU9mV2VlayIsIndlZWtkYXlGb3JtYXQiLCJpbnRsIiwic3RhcnREYXRlIiwiZGF5c09mV2VlayIsImkiLCJjdXJyZW50RGF0ZSIsInNldERhdGUiLCJnZXREYXRlIiwicHVzaCIsImdldERheXNPZk1vbnRoIiwiZmlyc3RPZk1vbnRoIiwiZ2V0RGF5Iiwib2Zmc2V0IiwiZGF5cyIsImdlbmVyYXRlVGltZSIsIm1pblBhcnRzIiwibWF4UGFydHMiLCJob3VyVmFsdWVzIiwibWludXRlVmFsdWVzIiwicHJvY2Vzc2VkSG91cnMiLCJwcm9jZXNzZWRNaW51dGVzIiwiaXNBTUFsbG93ZWQiLCJpc1BNQWxsb3dlZCIsImZpbHRlciIsImluY2x1ZGVzIiwiY29udmVydGVkSG91ciIsImlzUGFzdE1pbkhvdXIiLCJob3VycyIsImFtIiwicG0iLCJnZW5lcmF0ZU1vbnRocyIsImdldE1vbnRoQ29sdW1uRGF0YSIsIm1vbnRoVmFsdWVzIiwibW9udGhzIiwicHJvY2Vzc2VkTW9udGhzIiwiZm9yRWFjaCIsInByb2Nlc3NlZE1vbnRoIiwibW9udGhTdHJpbmciLCJ0ZXh0IiwibWF4TW9udGgiLCJtaW5Nb250aCIsImdldERheUNvbHVtbkRhdGEiLCJkYXlWYWx1ZXMiLCJtYXhEYXkiLCJtaW5EYXkiLCJwcm9jZXNzZWREYXlzIiwicHJvY2Vzc2VkRGF5IiwiZGF5U3RyaW5nIiwiZ2V0WWVhckNvbHVtbkRhdGEiLCJ5ZWFyVmFsdWVzIiwicHJvY2Vzc2VkWWVhcnMiLCJtYXhZZWFyIiwibWluWWVhciIsImdldEFsbE1vbnRoc0luUmFuZ2UiLCJnZXRDb21iaW5lZERhdGVDb2x1bW5EYXRhIiwidG9kYXlQYXJ0cyIsIml0ZW1zIiwibW9udGhPYmplY3QiLCJyZWZlcmVuY2VNb250aCIsIm1vbnRoRGF5cyIsImRhdGVQYXJ0cyIsImRhdGVDb2x1bW5JdGVtcyIsImRheU9iamVjdCIsImlzVG9kYXkiLCJnZXRUaW1lQ29sdW1uc0RhdGEiLCJhbGxvd2VkSG91clZhbHVlcyIsImFsbG93ZWRNaW51dGVWYXVlcyIsImhvdXJzSXRlbXMiLCJtaW51dGVzSXRlbXMiLCJkYXlQZXJpb2RJdGVtcyIsIm1pbnV0ZXNEYXRhIiwiaG91cnNEYXRhIiwiZGF5UGVyaW9kRGF0YSIsIklTT184NjAxX1JFR0VYUCIsIlRJTUVfUkVHRVhQIiwiY29udmVydFRvQXJyYXlPZk51bWJlcnMiLCJpbnB1dCIsInByb2Nlc3NlZElucHV0IiwicmVwbGFjZSIsInNwbGl0IiwidmFsdWVzIiwibnVtIiwicGFyc2VJbnQiLCJpc0Zpbml0ZSIsImdldFBhcnRzRnJvbUNhbGVuZGFyRGF5IiwiZ2V0QXR0cmlidXRlIiwicGFyc2VEYXRlIiwidmFsU3RyIiwicGFyc2UiLCJleGVjIiwidW5zaGlmdCIsImNsYW1wRGF0ZSIsInBhcnNlQW1QbSIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiSSIsIkoiLCJLIiwiTCIsIk0iLCJOIiwiYyIsImQiLCJlIiwiZiIsImciLCJoIiwiaiIsImsiLCJsIiwibSIsIm4iLCJvIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsImhvc3RDb250ZXh0Iiwic2VsZWN0b3IiLCJjbG9zZXN0IiwiY3JlYXRlQ29sb3JDbGFzc2VzIiwiY29sb3IiLCJjc3NDbGFzc01hcCIsImdldENsYXNzTGlzdCIsImNsYXNzZXMiLCJhcnJheSIsInRyaW0iLCJnZXRDbGFzc01hcCIsIlNDSEVNRSIsIm9wZW5VUkwiLCJ1cmwiLCJldiIsImRpcmVjdGlvbiIsImFuaW1hdGlvbiIsInRlc3QiLCJyb3V0ZXIiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJwcmV2ZW50RGVmYXVsdCJdLCJzb3VyY2VSb290Ijoid2VicGFjazovLy8iLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMCwxLDJdfQ==